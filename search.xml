<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android-RecyclerView滚动时干了什么？</title>
    <url>/2021/05/19/Android-RecyclerView%E6%BB%9A%E5%8A%A8%E6%97%B6%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="RecyclerView滚动时干了什么？"><a href="#RecyclerView滚动时干了什么？" class="headerlink" title="RecyclerView滚动时干了什么？"></a>RecyclerView滚动时干了什么？</h1><p>谈到RecyclerView的时候，复用机制是我们能脱口而出的优点之一。系统内置的ViewHolder避免了使用ListView时手动去创建ViewHolder的麻烦。关于何时回收View，何时复用View，我们能做到胸有成竹吗？当我们滑动一个RecyclerView时，是先回收View，再复用View？还是先复用View，再回收View呢？答案是都有可能。详情且看下面分析：</p>
<p><strong>名词解释</strong></p>
<p><strong>1. 回收：是指View不需要再展示在屏幕中，被回收到回收池中</strong></p>
<p><strong>2. 复用：本文中的复用是指调用了onCreateViewHolder或者onBindViewHolder方法</strong></p>
<p><strong>本文大纲</strong></p>
<p><strong>1. 滑动RV的两个场景</strong></p>
<p><strong>2. DEMO验证答案</strong></p>
<p><strong>3. 滑动原理讲解</strong></p>
<p><strong>4. 源码分析</strong></p>
<p><strong>5. 提问互动</strong></p>
<h2 id="1-滑动RV的两个场景"><a href="#1-滑动RV的两个场景" class="headerlink" title="1.滑动RV的两个场景"></a>1.滑动RV的两个场景</h2><h3 id="1-1-场景一"><a href="#1-1-场景一" class="headerlink" title="1.1 场景一"></a>1.1 场景一</h3><p>RV中每个Item高度都为100px，最后一个Item超出屏幕50px。RV初始状态如下图        </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9be83770378a4458b79a0cbf2dc365f7~tplv-k3u1fbpfcp-zoom-1.image" alt="场景一"></p>
<p>Q1 假设向上滑动40px</p>
<p>请问是否有View发生回收和复用？如果有，先复用还是先回收？</p>
<p>$\color{red}{答    回收和复用都没有发生}$</p>
<p>Q2    假设向上滑动60px</p>
<p>请问是否有View发生回收和复用？如果有，先复用还是先回收？</p>
<p>$\color{red}{答    没有发生回收，发生了复用}$</p>
<p>Q3    假设向上滑动120px</p>
<p>请问是否有View发生回收和复用？如果有，先复用还是先回收？</p>
<p>$\color{red}{答    发生了回收和复用。先复用后回收}$</p>
<h3 id="1-2-场景二"><a href="#1-2-场景二" class="headerlink" title="1.2 场景二"></a>1.2 场景二</h3><p>RV中第一个Item高度为50px，其它都为100px，最后一个Item超出屏幕95px。RV初始状态如下</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cae471defcc04a93a7a0f11e3b85d621~tplv-k3u1fbpfcp-zoom-1.image" alt="场景二"></p>
<p>Q1    假设向上滑动40px</p>
<p>请问是否有View发生回收和复用？如果有，先复用还是先回收？</p>
<p>$\color{red}{答    回收和复用都没有发生}$</p>
<p>Q2    假设向上滑动60px</p>
<p>请问是否有View发生回收和复用？如果有，先复用还是先回收？</p>
<p>$\color{red}{答    发生了回收，没有发生复用}$</p>
<p>Q3    假设向上滑动120px</p>
<p>请问是否有View发生回收和复用？如果有，先复用还是先回收？</p>
<p>$\color{red}{答    发生了回收和复用。先回收后复用}$</p>
<p>从答案可以看出。回收和复用并没有固定的答案。它因场景而异。下面我们通过案例验证答案真伪。  </p>
<h2 id="2-DEMO验证答案"><a href="#2-DEMO验证答案" class="headerlink" title="2. DEMO验证答案"></a>2. DEMO验证答案</h2><h3 id="2-1-我们来验证场景一"><a href="#2-1-我们来验证场景一" class="headerlink" title="2.1 我们来验证场景一"></a>2.1 我们来验证场景一</h3><p>程序运行图  </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fee2c707893492aa3e158b1ce6a98d6~tplv-k3u1fbpfcp-zoom-1.image"><br>程序代码  </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerViewActivity1</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mRecyclerView: RecyclerView</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_recycler_view1)</span><br><span class="line">        mRecyclerView = findViewById(R.id.recyclerview)</span><br><span class="line">        mRecyclerView.setHasFixedSize(<span class="literal">true</span>)</span><br><span class="line">        mRecyclerView.setItemViewCacheSize(<span class="number">0</span>)</span><br><span class="line">        mRecyclerView.layoutManager =</span><br><span class="line">            LinearLayoutManager(<span class="keyword">this</span>).apply &#123;</span><br><span class="line">                orientation = LinearLayoutManager.VERTICAL</span><br><span class="line">                isItemPrefetchEnabled = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">val</span> list: MutableList&lt;String&gt; =</span><br><span class="line">            ArrayList()</span><br><span class="line">        repeat(<span class="number">100</span>) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;item <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        mRecyclerView.adapter = MyAdapter(list)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span></span>(<span class="keyword">val</span> mStrings: MutableList&lt;String&gt;) :</span><br><span class="line">        RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: RecyclerView.ViewHolder &#123;</span><br><span class="line">            println(<span class="string">&quot;RecyclerView 场景一 onCreateViewHolder &quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> view = LayoutInflater.from(parent.context)</span><br><span class="line">                .inflate(R.layout.view_item, parent, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">object</span> : RecyclerView.ViewHolder(view) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mStrings.size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;RecyclerView 场景一 onBindViewHolder <span class="variable">$position</span> &quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> textView = holder.itemView <span class="keyword">as</span> TextView</span><br><span class="line">            textView.layoutParams.height = (resources.displayMetrics.density * <span class="number">100</span>).toInt()</span><br><span class="line">            textView.text = mStrings[position]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewRecycled</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;RecyclerView 场景一 发生回收 &quot;</span> + (holder.itemView <span class="keyword">as</span> TextView).text)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">super</span>.onViewRecycled(holder)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">scroll120</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        mRecyclerView.scrollBy(<span class="number">0</span>, (resources.displayMetrics.density * <span class="number">120</span>).toInt())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">scroll60</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        mRecyclerView.scrollBy(<span class="number">0</span>, (resources.displayMetrics.density * <span class="number">60</span>).toInt())</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">scroll40</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        mRecyclerView.scrollBy(<span class="number">0</span>, (resources.displayMetrics.density * <span class="number">40</span>).toInt())</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志输出如下</p>
<blockquote>
<p>首先进入初始状态</p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 0 </p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 1 </p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 2 </p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 3 </p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 4 </p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 5</p>
</blockquote>
<blockquote>
<p>点击上滑40px。打印日志不变。证明 回收和复用都没有发生  </p>
</blockquote>
<blockquote>
<p>点击上滑60px。打印日志如下。证明 没有发生回收，发生了复用</p>
<p>RecyclerView 场景一 onCreateViewHolder</p>
<p>RecyclerView 场景一 onBindViewHolder 0</p>
<p>RecyclerView 场景一 onCreateViewHolder</p>
<p>RecyclerView 场景一 onBindViewHolder 1</p>
<p>RecyclerView 场景一 onCreateViewHolder</p>
<p>RecyclerView 场景一 onBindViewHolder 2</p>
<p>RecyclerView 场景一 onCreateViewHolder</p>
<p>RecyclerView 场景一 onBindViewHolder 3</p>
<p>RecyclerView 场景一 onCreateViewHolder</p>
<p>RecyclerView 场景一 onBindViewHolder 4</p>
<p>RecyclerView 场景一 onCreateViewHolder</p>
<p>RecyclerView 场景一 onBindViewHolder 5</p>
<p>RecyclerView 场景一 onCreateViewHolder //只发生了复用<br>RecyclerView 场景一 onBindViewHolder 6</p>
</blockquote>
<blockquote>
<p>点击上滑动120px。打印日志如下。证明 发生了回收和复用。先复用后回收</p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 0 </p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 1 </p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 2 </p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 3 </p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 4 </p>
<p>RecyclerView 场景一 onCreateViewHolder </p>
<p>RecyclerView 场景一 onBindViewHolder 5</p>
<p>RecyclerView 场景一 onCreateViewHolder //先复用 </p>
<p>RecyclerView 场景一 onBindViewHolder 6</p>
<p>RecyclerView 场景一 发生回收 item 0  //后回收</p>
</blockquote>
<h3 id="2-2-我们来验证场景二"><a href="#2-2-我们来验证场景二" class="headerlink" title="2.2 我们来验证场景二"></a>2.2 我们来验证场景二</h3><p>程序运行图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b2c035480b14deaa0a9023ba693fdff~tplv-k3u1fbpfcp-zoom-1.image">  </p>
<p>程序代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecyclerViewActivity2</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mRecyclerView: RecyclerView</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_recycler_view2)</span><br><span class="line">        mRecyclerView = findViewById(R.id.recyclerview)</span><br><span class="line">        mRecyclerView.setHasFixedSize(<span class="literal">true</span>)</span><br><span class="line">        mRecyclerView.setItemViewCacheSize(<span class="number">0</span>)</span><br><span class="line">        mRecyclerView.layoutManager =</span><br><span class="line">            LinearLayoutManager(<span class="keyword">this</span>).apply &#123;</span><br><span class="line">                orientation = LinearLayoutManager.VERTICAL</span><br><span class="line">                isItemPrefetchEnabled = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">val</span> list: MutableList&lt;String&gt; =</span><br><span class="line">            ArrayList()</span><br><span class="line">        repeat(<span class="number">100</span>) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;item <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        mRecyclerView.adapter = MyAdapter(list)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdapter</span></span>(<span class="keyword">val</span> mStrings: MutableList&lt;String&gt;) :</span><br><span class="line">        RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: RecyclerView.ViewHolder &#123;</span><br><span class="line">            println(<span class="string">&quot;RecyclerView 场景二 onCreateViewHolder &quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> view = LayoutInflater.from(parent.context)</span><br><span class="line">                .inflate(R.layout.view_item, parent, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">object</span> : RecyclerView.ViewHolder(view) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mStrings.size</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;RecyclerView 场景二 onBindViewHolder <span class="variable">$position</span> &quot;</span>)</span><br><span class="line">            <span class="keyword">val</span> textView = holder.itemView <span class="keyword">as</span> TextView</span><br><span class="line">            textView.layoutParams.height =</span><br><span class="line">                <span class="keyword">if</span> (position == <span class="number">0</span>) (resources.displayMetrics.density * <span class="number">50</span>).toInt() <span class="keyword">else</span> (resources.displayMetrics.density * <span class="number">100</span>).toInt()</span><br><span class="line">            textView.text = mStrings[position]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewRecycled</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>)</span></span> &#123;</span><br><span class="line">            println(<span class="string">&quot;RecyclerView 场景二 发生回收 &quot;</span> + (holder.itemView <span class="keyword">as</span> TextView).text)</span><br><span class="line">            <span class="keyword">super</span>.onViewRecycled(holder)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">scroll120</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        mRecyclerView.scrollBy(<span class="number">0</span>, (resources.displayMetrics.density * <span class="number">120</span>).toInt())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">scroll60</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        mRecyclerView.scrollBy(<span class="number">0</span>, (resources.displayMetrics.density * <span class="number">60</span>).toInt())</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">scroll40</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        mRecyclerView.scrollBy(<span class="number">0</span>, (resources.displayMetrics.density * <span class="number">40</span>).toInt())</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>日志输出首先进入初始状态</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 0</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 1</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 2</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 3</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 4</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 5</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 6</p>
</blockquote>
<blockquote>
<p>点击上滑40px。打印日志不变。证明 回收和复用都没有发生  </p>
</blockquote>
<blockquote>
<p>点击上滑60px。打印日志如下。证明 发生回收，没有发生复用</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 0</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 1</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 2</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 3</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 4</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 5</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 6</p>
<p>RecyclerView 场景二 发生回收 item 0   //只发生了回收</p>
</blockquote>
<blockquote>
<p>点击上滑动120px。打印日志如下。证明 发生了回收和复用。先回收后复用</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 0</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 1</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 2</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 3</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 4</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 5</p>
<p>RecyclerView 场景二 onCreateViewHolder</p>
<p>RecyclerView 场景二 onBindViewHolder 6</p>
<p>RecyclerView 场景二 发生回收 item 0 //先回收</p>
<p>RecyclerView 场景二 onBindViewHolder 7 //再复用</p>
</blockquote>
<h2 id="3-滑动原理分析"><a href="#3-滑动原理分析" class="headerlink" title="3. 滑动原理分析"></a>3. 滑动原理分析</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e9e34fd43034173912c8a7fff713f65~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>如图所示，介绍几个关于坐标的参数  </p>
<ol>
<li><p> delta：手指滑动的距离120px。  </p>
</li>
<li><p> mOffset：RV最后一个子View的Bottom在屏幕坐标系的Y坐标600px。RV的下一个View(Item7)从mOffset处布局。</p>
</li>
<li><p> mScrollingOffset：RV最后一个子view的Bottom距离RV Bottom的距离50px。向上滑动不超过该距离。如超过需创建新的View填充。</p>
</li>
<li><p> mVailable：delta-mScrollingOffset。可以填充View的空间。如果大于0表示有空间填充新的View</p>
</li>
<li><p>如果delta&lt;mScrollingOffset，mScrollingOffset=delta，mVailable&lt;0  </p>
</li>
</ol>
<p>滑动逻辑如下  </p>
<ol>
<li><p>  从RecyclerView的第0个View开始遍历，直到View的Bottom&gt;mScrollingOffset,并记录该View的下标index，回收[0,index)区间的View，index为开区间，如果index&gt;=1,则会将[0,index)区间的View移除屏幕，并按照回收算法放入回收池。具体回收算法先按下不表。</p>
</li>
<li><p> 如果mVailable&gt;0，则从mOffset处，用新的View填充。mOffset+=新View的高度，mVailable-=新View的高度，mScrollingOffset+=新View的高度，如果mVailable&lt;0，mScrollingOffset+=mVailable。布局完成后用步骤1的算法按需回收上面的View。</p>
</li>
<li><p> 重复步骤2</p>
</li>
<li><p> 将RV整体，向上移动delta或者consumed距离(一般是delta距离，但是当RecyclerView下面没有Item时会是具体消耗掉的距离)  </p>
</li>
</ol>
<p>根据此滑动逻辑，我们分析场景一中的向上滑动120px<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b422bb36e19245698c2c240890bb5c5f~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>mOffset = 600px  </p>
<p>mScrollingOffset = 50px</p>
<p>mAvailable = 70px</p>
<p>item1高度100px  </p>
<ol>
<li><p> 首先从第0个View遍历Bottom&gt;50px。找到item1.bottom=100px，记录index=0。因为index&lt;1。所以不发生回收  </p>
</li>
<li><p> mAvailable&gt;0，从Item6的底部，增加View Item7(此处发生复用逻辑)高度为100px，mOffset=700px，mAvailable=-30，mScrollingOffset=mScrollingOffset+100-30=120px。然后检查回收。首先从第0个View遍历Bottom&gt;120px。找到item2.bottom=200px，记录index=1。回收[0,1)区间的View。即回收Item1</p>
</li>
<li><p> mAvailable=-30&lt;0,退出填充逻辑</p>
</li>
<li><p> 整体向上移动120px</p>
</li>
</ol>
<p>我们看到先创建Item7 然后回收Item1。跟日志相符合  </p>
<p>RecyclerView 场景一 onCreateViewHolder //先复用<br>RecyclerView 场景一 onBindViewHolder 6</p>
<p>RecyclerView 场景一 发生回收 item 0  //后回收</p>
<p>同样的逻辑我们也可以分析场景二中的向上滑动120px的情况。场景二会先发生回收，再发生复用。读者可以自己去求证。  </p>
<h2 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4.源码分析"></a>4.源码分析</h2><p>RV的滑动，最终会调用LayoutManager的scrollBy方法。我们使用的是LinearLayoutManager。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinearLayoutManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> delta, RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getChildCount() == <span class="number">0</span> || delta == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ensureLayoutState();</span><br><span class="line">        mLayoutState.mRecycle = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = delta &gt; <span class="number">0</span> ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> absDelta = Math.abs(delta);</span><br><span class="line">        ##代码<span class="number">1</span> updateLayoutState方法，主要是计算mOffset等参数。</span><br><span class="line">        updateLayoutState(layoutDirection, absDelta, <span class="keyword">true</span>, state);</span><br><span class="line">        ##代码<span class="number">2</span> fill方法，根据剩余空间，填充View</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> consumed = mLayoutState.mScrollingOffset</span><br><span class="line">                + </span><br><span class="line">                fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (consumed &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;Don&#x27;t have any more elements to scroll&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> scrolled = absDelta &gt; consumed ? layoutDirection * consumed : delta;</span><br><span class="line">        ##代码<span class="number">3</span> offsetChildren，整体移动RV的子View</span><br><span class="line">        mOrientationHelper.offsetChildren(-scrolled);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;scroll req: &quot;</span> + delta + <span class="string">&quot; scrolled: &quot;</span> + scrolled);</span><br><span class="line">        &#125;</span><br><span class="line">        mLayoutState.mLastScrollDelta = scrolled;</span><br><span class="line">        <span class="keyword">return</span> scrolled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>##代码1 updateLayoutState方法，主要是计算mOffset等参数。</p>
<p>##代码2 fill方法，根据剩余空间，填充View</p>
<p>##代码3 offsetChildren，整体移动RV的子View</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主要是计算</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateLayoutState</span><span class="params">(<span class="keyword">int</span> layoutDirection, <span class="keyword">int</span> requiredSpace,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> canUseExistingSpace, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If parent provides a hint, don&#x27;t measure unlimited.</span></span><br><span class="line">        mLayoutState.mInfinite = resolveIsInfinite();</span><br><span class="line">        mLayoutState.mLayoutDirection = layoutDirection;</span><br><span class="line">        mReusableIntPair[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        mReusableIntPair[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        calculateExtraLayoutSpace(state, mReusableIntPair);</span><br><span class="line">        <span class="keyword">int</span> extraForStart = Math.max(<span class="number">0</span>, mReusableIntPair[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> extraForEnd = Math.max(<span class="number">0</span>, mReusableIntPair[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">boolean</span> layoutToEnd = layoutDirection == LayoutState.LAYOUT_END;</span><br><span class="line">        mLayoutState.mExtraFillSpace = layoutToEnd ? extraForEnd : extraForStart;</span><br><span class="line">        mLayoutState.mNoRecycleSpace = layoutToEnd ? extraForStart : extraForEnd;</span><br><span class="line">        <span class="keyword">int</span> scrollingOffset;</span><br><span class="line">        <span class="keyword">if</span> (layoutToEnd) &#123;</span><br><span class="line">            mLayoutState.mExtraFillSpace += mOrientationHelper.getEndPadding();</span><br><span class="line">            <span class="comment">// get the first child in the direction we are going</span></span><br><span class="line">            <span class="keyword">final</span> View child = getChildClosestToEnd();</span><br><span class="line">            <span class="comment">// the direction in which we are traversing children</span></span><br><span class="line">            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD</span><br><span class="line">                    : LayoutState.ITEM_DIRECTION_TAIL;</span><br><span class="line">            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;</span><br><span class="line">            mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child);</span><br><span class="line">            <span class="comment">// calculate how much we can scroll without adding new children (independent of layout)</span></span><br><span class="line">            scrollingOffset = mOrientationHelper.getDecoratedEnd(child)</span><br><span class="line">                    - mOrientationHelper.getEndAfterPadding();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = getChildClosestToStart();</span><br><span class="line">            mLayoutState.mExtraFillSpace += mOrientationHelper.getStartAfterPadding();</span><br><span class="line">            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL</span><br><span class="line">                    : LayoutState.ITEM_DIRECTION_HEAD;</span><br><span class="line">            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;</span><br><span class="line">            mLayoutState.mOffset = mOrientationHelper.getDecoratedStart(child);</span><br><span class="line">            scrollingOffset = -mOrientationHelper.getDecoratedStart(child)</span><br><span class="line">                    + mOrientationHelper.getStartAfterPadding();</span><br><span class="line">        &#125;</span><br><span class="line">        mLayoutState.mAvailable = requiredSpace;</span><br><span class="line">        <span class="keyword">if</span> (canUseExistingSpace) &#123;</span><br><span class="line">            mLayoutState.mAvailable -= scrollingOffset;</span><br><span class="line">        &#125;</span><br><span class="line">        mLayoutState.mScrollingOffset = scrollingOffset;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span></span></span><br><span class="line"><span class="params"><span class="function">            RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// max offset we should set is mFastScroll + available</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> start = layoutState.mAvailable;</span><br><span class="line">        <span class="keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">            <span class="comment">// TODO ugly bug fix. should not happen</span></span><br><span class="line">            <span class="keyword">if</span> (layoutState.mAvailable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                layoutState.mScrollingOffset += layoutState.mAvailable;</span><br><span class="line">            &#125;</span><br><span class="line">            ##代码<span class="number">1</span> 首先判断是否需要回收<span class="function">View</span></span><br><span class="line"><span class="function">            <span class="title">recycleByLayoutState</span><span class="params">(recycler, layoutState)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtraFillSpace;</span><br><span class="line">        LayoutChunkResult layoutChunkResult = mLayoutChunkResult;</span><br><span class="line">        ##代码<span class="number">2</span> 根据剩余空间，判断是否需要填充<span class="function">View</span></span><br><span class="line"><span class="function">        <span class="title">while</span> <span class="params">((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>)</span> &amp;&amp; layoutState.<span class="title">hasMore</span><span class="params">(state)</span>) </span>&#123;</span><br><span class="line">            layoutChunkResult.resetInternal();</span><br><span class="line">            <span class="keyword">if</span> (RecyclerView.VERBOSE_TRACING) &#123;</span><br><span class="line">                TraceCompat.beginSection(<span class="string">&quot;LLM LayoutChunk&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ##代码<span class="number">3</span> 是具体的layout方法</span><br><span class="line">            layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">            <span class="keyword">if</span> (RecyclerView.VERBOSE_TRACING) &#123;</span><br><span class="line">                TraceCompat.endSection();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (layoutChunkResult.mFinished) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Consume the available space if:</span></span><br><span class="line"><span class="comment">             * * layoutChunk did not request to be ignored</span></span><br><span class="line"><span class="comment">             * * OR we are laying out scrap children</span></span><br><span class="line"><span class="comment">             * * OR we are not doing pre-layout</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!layoutChunkResult.mIgnoreConsumed || layoutState.mScrapList != <span class="keyword">null</span></span><br><span class="line">                    || !state.isPreLayout()) &#123;</span><br><span class="line">                layoutState.mAvailable -= layoutChunkResult.mConsumed;</span><br><span class="line">                <span class="comment">// we keep a separate remaining space because mAvailable is important for recycling</span></span><br><span class="line">                remainingSpace -= layoutChunkResult.mConsumed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) &#123;</span><br><span class="line">                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;</span><br><span class="line">                <span class="keyword">if</span> (layoutState.mAvailable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    layoutState.mScrollingOffset += layoutState.mAvailable;</span><br><span class="line">                &#125;</span><br><span class="line">                ##代码<span class="number">4</span> 是layout完成后判断是否需要回收<span class="function">View</span></span><br><span class="line"><span class="function">                <span class="title">recycleByLayoutState</span><span class="params">(recycler, layoutState)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            validateChildOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>##代码1，首先判断是否需要回收View</p>
<p>##代码2，根据剩余空间，判断是否需要填充View</p>
<p>##代码3 是具体的layout方法</p>
<p>##代码4 是layout完成后判断是否需要回收View</p>
<p>本文主要讲解了滑动时的回收和复用的逻辑。具体如何如何回收，如何复用。RecyclerView的三级缓存是如何实现的。且听下回分解。</p>
<h2 id="5-提问互动"><a href="#5-提问互动" class="headerlink" title="5. 提问互动"></a>5. 提问互动</h2><p>最后为了巩固大家对知识的理解，提出一个问题，请在评论区写出你的答案吧。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b422bb36e19245698c2c240890bb5c5f~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p><strong>问题一 场景一的case3，向上滑动120px，120px大于第一个Item的高度100px，为何不先让Item1先回收掉呢？</strong></p>
<p><strong>问题二 谷歌这么设计的原因可能是什么？</strong></p>
<h4 id="Written-By-多点-移动运营研发部-姜斌"><a href="#Written-By-多点-移动运营研发部-姜斌" class="headerlink" title="Written By 多点-移动运营研发部-姜斌"></a>Written By 多点-移动运营研发部-姜斌</h4>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeSnippets使用说明</title>
    <url>/2021/05/19/CodeSnippets%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h3 id="CodeSnippets"><a href="#CodeSnippets" class="headerlink" title="CodeSnippets"></a>CodeSnippets</h3><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><ul>
<li>第一种 前往文件夹：<br>前往文件夹：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/Library/Developer/Xcode/UserData/CodeSnippets</span><br></pre></td></tr></table></figure>
然后复制粘贴即可</li>
<li>第二种 执行脚本即可<br>进入到当前文件根目录。然后执行脚本即可。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh DMCodeSnippets.sh</span><br></pre></td></tr></table></figure>
如果没有权限,在终端添加<code>sudo</code>,输入电脑密码，执行脚本即可。<br><code>sudo sh  DMCodeSnippets.sh</code></li>
</ul>
<h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><table>
<thead>
<tr>
<th>快捷方式</th>
<th>功能</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>DMArray</td>
<td>不可变数组的声明</td>
<td>@property (nonatomic, copy) NSArray *&lt;#array#&gt;;</td>
</tr>
<tr>
<td>DMBOOL</td>
<td>基本数据类型BOOL</td>
<td>@property (nonatomic, assign) BOOL  &lt;#bool#&gt;;</td>
</tr>
<tr>
<td>DMDictionary</td>
<td>不可变字典属性声明</td>
<td>@property (nonatomic, copy) NSDictionary *&lt;#dictionary#&gt;;</td>
</tr>
<tr>
<td>DMMutableDictInterface</td>
<td>可变字典属性声明</td>
<td>@property (nonatomic, strong) NSMutableDictionary *&lt;#mutableDictionary#&gt;;</td>
</tr>
<tr>
<td>DMMutableDictLazyLoading</td>
<td>可变字典懒加载</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMInteger</td>
<td>NSInteger基本数据类型</td>
<td>@property (nonatomic, assign) NSInteger  &lt;#integer#&gt;;</td>
</tr>
<tr>
<td>DMString</td>
<td>字符串声明</td>
<td>@property (nonatomic, copy) NSString *&lt;#string#&gt;;</td>
</tr>
<tr>
<td>DMMutableArrayInterface</td>
<td>可变数组声明</td>
<td>@property (nonatomic, strong) NSMutableArray *&lt;#mutableArray#&gt;;</td>
</tr>
<tr>
<td>DMMutableArrayLazyLoading</td>
<td>可变数组懒加载</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMLabelInterface</td>
<td>UILabel声明</td>
<td>@property (nonatomic, strong) UILabel *&lt;#contentLabel#&gt;;</td>
</tr>
<tr>
<td>DMLabelLazyLoading</td>
<td>UILabel懒加载</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMButtonInterface</td>
<td>UIButton声明</td>
<td>@property (nonatomic, strong) UIButton *&lt;#customBtn#&gt;;</td>
</tr>
<tr>
<td>DMButtonLazyLoading</td>
<td>UIButton懒加载</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMImageViewInterface</td>
<td>UIImageView声明</td>
<td>@property (nonatomic, strong) UIImageView *&lt;#iconImageView#&gt;;</td>
</tr>
<tr>
<td>DMImageViewLazyLoading</td>
<td>UIImageView懒加载</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMViewInterface</td>
<td>UIView声明</td>
<td>@property (nonatomic, strong) UIView *&lt;#contentView#&gt;;</td>
</tr>
<tr>
<td>DMViewLazyLoading</td>
<td>UIView懒加载</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMPragmaMark</td>
<td>pragmaMark</td>
<td>#pragma mark   - &lt;#infoMessage#&gt; -</td>
</tr>
<tr>
<td>DMWarning</td>
<td>warning，包括作者，以及warning描述</td>
<td>#warning   &lt;#author#&gt;   &lt;#messageDesc#&gt;</td>
</tr>
<tr>
<td>DMDispatchOnce</td>
<td>单例中dispatch_once写法</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMGCDAsyMain</td>
<td>异步回到主线程</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMWeakSelf</td>
<td>weak修饰写法</td>
<td>__weak typeof(self)weakSelf = self;</td>
</tr>
<tr>
<td>DMStrongSelf</td>
<td>strong修饰写法</td>
<td>__strong typeof(weakSelf)strongSelf = weakSelf;</td>
</tr>
<tr>
<td>DMLocalBlock</td>
<td>localBlock</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMInitMethod</td>
<td>初始化方法</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMLifecycle</td>
<td>vc生命周期</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMTableViewInterface</td>
<td>UITabeleView声明</td>
<td>@property (nonatomic, strong) UITableView *&lt;#tableView#&gt;;</td>
</tr>
<tr>
<td>DMTableViewLazyLoading</td>
<td>UITableView懒加载</td>
<td>实现见下面</td>
</tr>
<tr>
<td>DMCollectionViewInterface</td>
<td>UICollectionView声明</td>
<td>@property (nonatomic, strong) UICollectionView *&lt;#collectionView#&gt;;</td>
</tr>
<tr>
<td>DMCollectionViewLazyLoading</td>
<td>UICollectionView懒加载</td>
<td>实现见下面</td>
</tr>
</tbody></table>
<h4 id="DMButtonLazyLoading"><a href="#DMButtonLazyLoading" class="headerlink" title="DMButtonLazyLoading"></a>DMButtonLazyLoading</h4><p>实现：UIButton实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (UIButton *)&lt;#customBtn#&gt; &#123;</span><br><span class="line">    if (!&lt;#_customBtn#&gt;) &#123;</span><br><span class="line">        &lt;#_customBtn#&gt; = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">        [&lt;#_customBtn#&gt; setTitle:&lt;#(nullable NSString *)#&gt; forState:UIControlStateNormal];</span><br><span class="line">        [&lt;#_customBtn#&gt; setTitleColor:&lt;#(nullable UIColor *)#&gt; forState:UIControlStateNormal];</span><br><span class="line">        [&lt;#_customBtn#&gt; setBackgroundColor:&lt;#(UI_APPEARANCE_SELECTOR UIColor *)#&gt;];</span><br><span class="line">        [&lt;#_customBtn#&gt; addTarget:&lt;#(nullable id)#&gt; action:&lt;#(nonnull SEL)#&gt; forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;#_customBtn#&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DMDispatchOnce"><a href="#DMDispatchOnce" class="headerlink" title="DMDispatchOnce"></a>DMDispatchOnce</h4><p>实现：单例中dispatch_once写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        &lt;#code#&gt;</span><br><span class="line">    &#125;);</span><br><span class="line">    return &lt;#expression#&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DMGCDAsyMain"><a href="#DMGCDAsyMain" class="headerlink" title="DMGCDAsyMain"></a>DMGCDAsyMain</h4><p>实现：异步回到主线程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       &lt;#code#&gt;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="DMImageViewLazyLoading"><a href="#DMImageViewLazyLoading" class="headerlink" title="DMImageViewLazyLoading"></a>DMImageViewLazyLoading</h4><p>实现：UIImageView懒加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (UIImageView *)&lt;#iconImageView#&gt; &#123;</span><br><span class="line">    if (!&lt;#_iconImageView#&gt;) &#123;</span><br><span class="line">        &lt;#_iconImageView#&gt; =[[UIImageView alloc]init];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;#_iconImageView#&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DMInitMethod"><a href="#DMInitMethod" class="headerlink" title="DMInitMethod"></a>DMInitMethod</h4><p>实现：初始化方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    </span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DMLabelLazyLoading"><a href="#DMLabelLazyLoading" class="headerlink" title="DMLabelLazyLoading"></a>DMLabelLazyLoading</h4><p>实现：UILabel懒加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (UILabel *)&lt;#contentLabel#&gt; &#123;</span><br><span class="line">    if (!&lt;#_contentLabel#&gt;) &#123;</span><br><span class="line">        &lt;#_contentLabel#&gt; = [[UILabel alloc]initWithFrame:CGRectMake(&lt;#CGFloat x#&gt;, &lt;#CGFloat y#&gt;, &lt;#CGFloat width#&gt;, &lt;#CGFloat height#&gt;)];</span><br><span class="line">        &lt;#_contentLabel#&gt;.backgroundColor = [UIColor clearColor];</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;#_contentLabel#&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DMLifecycle"><a href="#DMLifecycle" class="headerlink" title="DMLifecycle"></a>DMLifecycle</h4><p>实现：vc生命周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (void)pageInit &#123;</span><br><span class="line">    [super pageInit];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageWillForwardToMe &#123;</span><br><span class="line">    [super pageWillForwardToMe];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageDidForwardToMe &#123;</span><br><span class="line">    [super pageDidForwardToMe];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageWillBeShown &#123;</span><br><span class="line">    [super pageWillBeShown];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageDidShown &#123;</span><br><span class="line">    [super pageDidShown];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageWillForwardFromMe &#123;</span><br><span class="line">    [super pageWillForwardFromMe];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageDidForwardFromMe &#123;</span><br><span class="line">    [super pageDidForwardFromMe];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageWillBackwardFromMe &#123;</span><br><span class="line">    [super pageWillBackwardFromMe];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageDidBackwardFromMe &#123;</span><br><span class="line">    [super pageDidBackwardFromMe];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageWillBackwardToMe &#123;</span><br><span class="line">    [super pageWillBackwardToMe];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageDidBackwardToMe &#123;</span><br><span class="line">    [super pageDidBackwardToMe];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageWillBeHidden &#123;</span><br><span class="line">    [super pageWillBeHidden];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageDidHidden &#123;</span><br><span class="line">    [super pageDidHidden];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageDestroy &#123;</span><br><span class="line">    [super pageDestroy];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pageReload &#123;</span><br><span class="line">    [super pageReload];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DMLocalBlock"><a href="#DMLocalBlock" class="headerlink" title="DMLocalBlock"></a>DMLocalBlock</h4><p>实现：localBlock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;#returnType#&gt;(^&lt;#blocKname#&gt;)(&lt;#parameterTypes#&gt;) = ^&lt;#returnType#&gt; (&lt;#parameters#&gt;) &#123;</span><br><span class="line">    &lt;#statements#&gt;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="DMMutableArrayLazyLoading"><a href="#DMMutableArrayLazyLoading" class="headerlink" title="DMMutableArrayLazyLoading"></a>DMMutableArrayLazyLoading</h4><p>实现：可变数组懒加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (NSMutableArray *)&lt;#mutableArray#&gt; &#123;</span><br><span class="line">    if (!&lt;#_mutableArray#&gt;) &#123;</span><br><span class="line">        &lt;#_mutableArray#&gt; = [NSMutableArray array];</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;#_mutableArray#&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DMMutableDictLazyLoading"><a href="#DMMutableDictLazyLoading" class="headerlink" title="DMMutableDictLazyLoading"></a>DMMutableDictLazyLoading</h4><p>实现：可变字典懒加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (NSMutableDictionary *)&lt;#mutableDictionary#&gt; &#123;</span><br><span class="line">    if (!&lt;#_mutableDictionary#&gt;) &#123;</span><br><span class="line">        &lt;#_mutableDictionary#&gt; = [NSMutableDictionary dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;#_mutableDictionary#&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DMViewLazyLoading"><a href="#DMViewLazyLoading" class="headerlink" title="DMViewLazyLoading"></a>DMViewLazyLoading</h4><p>实现：UIView懒加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (UIView *)&lt;#contentView#&gt; &#123;</span><br><span class="line">    if (!&lt;#_contentView#&gt;) &#123;</span><br><span class="line">        &lt;#_contentView#&gt; = [[UIView alloc]initWithFrame:CGRectMake(&lt;#CGFloat x#&gt;, &lt;#CGFloat y#&gt;, &lt;#CGFloat width#&gt;, &lt;#CGFloat height#&gt;)];</span><br><span class="line">        &lt;#_contentView#&gt;.backgroundColor = [UIColor clearColor];</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;#_contentView#&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DMTableViewLazyLoading"><a href="#DMTableViewLazyLoading" class="headerlink" title="DMTableViewLazyLoading"></a>DMTableViewLazyLoading</h1><p>实现：UITableView懒加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (UITableView *)&lt;#tableView#&gt; &#123;</span><br><span class="line">    if (!&lt;#_tableView#&gt;) &#123;</span><br><span class="line">        &lt;#_tableView#&gt; = [[UITableView alloc]initWithFrame:&lt;#(CGRect)#&gt; style:UITableViewStylePlain];</span><br><span class="line">        &lt;#_tableView#&gt;.delegate = self;</span><br><span class="line">        &lt;#_tableView#&gt;.dataSource = self;</span><br><span class="line">        [self.view addSubview:&lt;#_tableView#&gt;];</span><br><span class="line">        [&lt;#_tableView#&gt; mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.edges.insets(UIEdgeInsetsMake(&lt;#CGFloat top#&gt;, &lt;#CGFloat left#&gt;, &lt;#CGFloat bottom#&gt;, &lt;#CGFloat right#&gt;));</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;#_tableView#&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="DMCollectionViewLazyLoading"><a href="#DMCollectionViewLazyLoading" class="headerlink" title="DMCollectionViewLazyLoading"></a>DMCollectionViewLazyLoading</h1><p>实现：UICollectionView懒加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (UICollectionView *)&lt;#collectionView#&gt; &#123;</span><br><span class="line">    if (!&lt;#_collectionView#&gt;) &#123;</span><br><span class="line">        &lt;#_collectionView#&gt; = [[UICollectionView alloc]initWithFrame:&lt;#(CGRect)#&gt; collectionViewLayout:&lt;#(nonnull UICollectionViewLayout *)#&gt;];</span><br><span class="line">        &lt;#_collectionView#&gt;.delegate = self;</span><br><span class="line">        &lt;#_collectionView#&gt;.dataSource = self;</span><br><span class="line">        [self.view addSubview:&lt;#_collectionView#&gt;];</span><br><span class="line">        [&lt;#_collectionView#&gt; mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">            make.edges.insets(UIEdgeInsetsMake(&lt;#CGFloat top#&gt;, &lt;#CGFloat left#&gt;, &lt;#CGFloat bottom#&gt;, &lt;#CGFloat right#&gt;));</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    return &lt;#_collectionView#&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Android事件分发机制分析</title>
    <url>/2021/05/19/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="事件分发机制分析"><a href="#事件分发机制分析" class="headerlink" title="事件分发机制分析"></a>事件分发机制分析</h1><p>Android事件分发是一个老生常谈的知识点。日常开发和求职过程中，都会碰到Android事件分发的问题。</p>
<p>Android的控件分为两类，ViewGoup和View。ViewGroup是控件的容器，可以包含多个子控件。View是控件的最小单位，它不能包裹其它的View。Android的ViewGroup对应的数据结构是树。</p>
<p>网上的事件分发的文章大多数是用线性的思维去分析控件树的事件遍历，我深以为不妥，经常让读者云里雾里，只见树木不见森林。</p>
<p>本文我将从树的深度遍历来讲解DOWN事件的分发流程，从单链表的线性遍历讲解MOVE、UP事件的分发流程。  </p>
<p><strong>本文大纲</strong></p>
<p><strong>1. Android控件对应的多叉树</strong> </p>
<p><strong>2. 手势事件类型</strong>  </p>
<p><strong>3. 事件分发涉及到的方法</strong></p>
<p><strong>4. DOWN事件的分发流程</strong></p>
<p><strong>5. MOVE、UP事件的分发流程</strong></p>
<p><strong>6. CANCEL事件触发时机以及分发流程</strong></p>
<p><strong>7. 通过实例讲解事件分发流程</strong></p>
<h2 id="1-Android控件对应的多叉树"><a href="#1-Android控件对应的多叉树" class="headerlink" title="1. Android控件对应的多叉树"></a>1. Android控件对应的多叉树</h2><p>假设我们有一个这样的场景</p>
<p>屏幕上有一个FrameLayout名叫vp1。vp1有三个子控件vp2、vp3、vp4，它们的类型是FrameLayout。vp2有三个子控件v1、v2、v3。vp3有三个子控件v4、v5、v6。vp4有三个子控件v7、v8、v9。子控件的类型都是View。为了方便起见我们假设这些控件都是铺满屏幕的。我们将vp1控件树翻译成多叉树。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizijin/bytestation@master/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/byte_station_ViewGroup%E6%A0%91%E5%BD%A2%E5%9B%BE.png" alt="控件多叉树"></p>
<p><strong>解释一下树节点ft的含义</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizijin/bytestation@master/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/byte_station_ViewGroup%E8%8A%82%E7%82%B9.png" alt="ViewGroup节点"></p>
<p>ft的是ViewGroup类中的mFirtstTouchTarget成员变量的简称。它对应的数据结构是<strong>单链表</strong>。当DOWN事件在onTouchEvent方法中返回true，会<strong>回溯</strong>设置父View的ft指针。</p>
<p><strong>举个例子</strong></p>
<p>当DOWN事件从vp1开始分发。<br>假设DOWN事件在v7的onTouchEvent方法中返回true。<br>那么v7的父控件vp4的ft会指向v7(可以这样简单理解，实际上指向的是v7封装的一个TouchTarget对象)。同理vp1的ft会指向vp4。所以就生成了一条vp1-&gt;vp4-&gt;v7的分发路径。这很重要。  </p>
<p>DOWN事件的分发是从vp1开始，假设所有的ViewGroup都不拦截事件，所有的View都不处理事件。事件会沿着最后一个子控件做深度遍历分发。以下用intercept代替onInterceptTouchEvent，touch代替onTouchEvent。</p>
<blockquote>
<p>调用流程如下</p>
<p>vp1(intercept) -&gt; vp4(intercept) -&gt; v9(touch) -&gt; v8(touch) -&gt;v7 (touch) -&gt; vp4(touch)-&gt; vp3 -&gt; v6(touch) -&gt; v5(touch) -&gt; v4(touch) -&gt; vp3(touch)-&gt; vp2 -&gt; v3(touch) -&gt; v2(touch) -&gt; v1(touch) -&gt; vp2(touch)-&gt; vp1(touch)</p>
</blockquote>
<p><strong>这只是DOWN事件分发的一个Case。根据是否拦截，View是否处理事件。它的遍历路径也会不一样。</strong>  </p>
<p>MOVE、UP事件分发也是从vp1开始。但是他们不同于DOWN事件的分发。它不会进行深度遍历。深度遍历是比较耗时的。如果vp1有后代View分发了事件。那么必然会通过ft生成一条分发路径。MOVE事件只需沿着分发路径线性分发就可以了。还是用上面的例子。如果v7分发了DOWN事件。那么MOVE、UP事件的分发即vp1(intercept) -&gt; vp4(intercept) -&gt; v7(touch)  </p>
<h2 id="2-手势事件类型"><a href="#2-手势事件类型" class="headerlink" title="2. 手势事件类型"></a>2. 手势事件类型</h2><p>本文主要讲解四种事件类型，DOWN、MOVE、UP、CANCEL。用户划动手机屏幕然后离开。Android系统首先会触发DOWN事件，紧接着一连串的MOVE事件，以UP事件收场。<strong>注意：触摸屏幕，事件之间没有任何依赖。有可能只有其中一种事件被分发。也有可能有多种事件类型被分发</strong>  </p>
<table>
<thead>
<tr>
<th align="left">事件类型</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ACTION_DOWN</td>
<td align="left">手指按下屏幕</td>
</tr>
<tr>
<td align="left">ACTION_MOVE</td>
<td align="left">手指划动屏幕</td>
</tr>
<tr>
<td align="left">ACTION_CANCEL</td>
<td align="left">事件被取消</td>
</tr>
<tr>
<td align="left">ACTION_UP</td>
<td align="left">手指离开屏幕</td>
</tr>
</tbody></table>
<h2 id="3-事件分发涉及到的方法"><a href="#3-事件分发涉及到的方法" class="headerlink" title="3. 事件分发涉及到的方法"></a>3. 事件分发涉及到的方法</h2><table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">dispatchTouchEvent</td>
<td align="left">事件分发逻辑</td>
</tr>
<tr>
<td align="left">onInterceptTouchEvent</td>
<td align="left">是否拦截事件 <strong>(ViewGroup专属)</strong></td>
</tr>
<tr>
<td align="left">onTouchEvent</td>
<td align="left">是否处理事件</td>
</tr>
</tbody></table>
<ol>
<li><p> dispatchTouchEvent方法是Android系统内部实现的事件分发逻辑。返回值为boolean类型。true表示该View或ViewGroup处理了事件，反之返回false。返回值含义同onTouchEvent的返回值。dispatchTouchEvent与onTouchEvent的区别在于，默认情况下前者的返回值依赖于后者的返回值，而且前者的侧重点在于制定事件分发的流程，后者的侧重点在于View或者ViewGroup是否处理该事件。</p>
</li>
<li><p>onInterceptTouchEvent方法是ViewGroup专属的方法。当返回值为true表示ViewGroup(假设vp1)需要拦截掉该事件。这里有两种情况</p>
<p> 2.1   如果vp1的后代view没有处理DOWN事件。那么事件会直接交给vp1的onTouchEvent处理</p>
<p> 2.2  如果vp1的后代v7处理了DOWN事件，此时vp1拦截了MOVE事件。首先会生成CANCEL事件交由vp4分发。先后置空vp4，vp1的ft对象，接下来的MOVE事件同a步骤</p>
</li>
<li><p>onTouchEvent方法返回值同dispatchTouchEvent方法。我们首先得明白一点。onTouchEvent返回true会且仅会落到某一个具体的控件上。不会有更多的控件的onTouchEvent返回true，换句话说有且仅有一个控件能够处理事件。<strong>只有DOWN事件的返回值才有意义</strong>。其它类型事件的返回值并不会影响事件分发的流程。我们以v8的onTouchEvent的DOWN事件返回值为例。</p>
<p> 3.1.  v8 DOWN事件返回true。表示v8处理该事件。在v8分发事件之前应该是 vp1(onInterceptTouchEvent) -&gt; vp4(onInterceptTouchEvent) -&gt; v9(onTouchEvent)-&gt; v8(onTouchEvent)。此时v8返回true。系统会中断vp4的child遍历(不再将事件交由v7分发)。向上回溯设置vp4的ft指向v8，vp1的ft指向vp4。</p>
<p> 3.2.  v8 DOWN事件返回false。事件继续交由v8的亲兄弟v7分发。</p>
</li>
</ol>
<h2 id="4-DOWN事件的分发流程"><a href="#4-DOWN事件的分发流程" class="headerlink" title="4.DOWN事件的分发流程"></a>4.DOWN事件的分发流程</h2><p>DOWN事件分发到vp1，会调用vp1的onInterceptTouchEvent。这里有拦截和不拦截两种情况。  </p>
<ol>
<li><p> 如果返回true，vp1拦截DOWN事件，DOWN事件直接交由vp1的onTouchEvent处理。</p>
</li>
<li><p> 如果返回false，vp1不拦截DOWN事件，DOWN事件将会交由vp1的最后一个子View分发。即交由vp4分发。</p>
</li>
</ol>
<p>拦截方法以此类推，如果vp4不拦截DOWN事件，将交由v9分发事件。因为v9是View类型。没有拦截方法，所以会直接调用v9的onTouchEvent方法。该方法有处理和不处理两种情况。  </p>
<ol>
<li><p> 如果返回false，v9不处理事件。那么事件继续向前分发交由v8分发，同理调用v8的onTouchEvent方法，v8不处理事件，继续交由v7处理。v7也不处理，vp4的子View到此遍历完成。此时vp4的ft为空，直接调用vp4的onTouchEvent方法。  </p>
</li>
<li><p> 如果返回true，v9处理事件。系统会中断vp4的子View遍历，DOWN事件分发结束。同时往上递归回溯设置父View的ft对象。vp4的ft指向v9，vp1的ft指向vp4。  </p>
</li>
</ol>
<p> <strong>总结：DOWN事件是通过深度遍历分发事件的。</strong>  </p>
<h2 id="5-MOVE、UP事件的分发流程"><a href="#5-MOVE、UP事件的分发流程" class="headerlink" title="5. MOVE、UP事件的分发流程"></a>5. MOVE、UP事件的分发流程</h2><p>MOVE事件分发到VP1。它与DOWN事件的区别是，它并不一定会调用onInterceptTouchEvent。它只有当vp1的ft不为空时才会调用onInterceptTouchEvent方法，否则会直接拦截掉事件。</p>
<ol>
<li><p>  当vp1的ft为空。直接拦截掉MOVE事件。调用VP1的onTouchEvent方法，注意这里onTouchEvent方法的返回值不会影响事件分发的流程。</p>
</li>
<li><p> 当vp1的ft不为空(当有后代View的onTouchEvent方法返回了true)。调用onInterceptTouchEvent方法，如果返回true，同上，直接调换用VP1的onTouchEvent方法。如果返回false，会通过ft的单链表线性分发事件。  </p>
</li>
</ol>
<p>UP事件同MOVE事件。这里就不分析了。  </p>
<p><strong>总结：MOVE、UP事件是通过线性遍历分发的。</strong>  </p>
<h2 id="6-CANCEL事件触发时机以及分发流程"><a href="#6-CANCEL事件触发时机以及分发流程" class="headerlink" title="6. CANCEL事件触发时机以及分发流程"></a>6. CANCEL事件触发时机以及分发流程</h2><p>前面我们讲到的DOWN、MOVE、UP事件都是由手触摸屏幕产生的。并没有讲到CANCEL是如何产生的。CANCEL不是由手触摸屏幕产生的。它是由系统生成。并且分发给View的。有一种场景会触发系统产生CANCEL事件。<br>还是上面的控件树。假设手机在屏幕的上半部分，所有的ViewGroup都不拦截事件，V9处理DOWN事件，当划动到屏幕的下半部分时，VP1拦截MOVE事件。当手指从上划动到下面时。系统将在vp1处，产生一个CANCEL事件，交由vp4分发。CANCEL事件的分发也是通过ft线性分发。当ViewGroup分发CANCEL事件后，会将ViewGroup的ft置为空。即将VP1，VP4的ft置为空。  </p>
<h2 id="7-通过实例讲解事件分发流程"><a href="#7-通过实例讲解事件分发流程" class="headerlink" title="7. 通过实例讲解事件分发流程"></a>7. 通过实例讲解事件分发流程</h2><p>本段将通过三个场景实战讲解事件分发流程  </p>
<p><strong>1.  所有的View都不分发事件，所有的ViewGroup都不拦截事件</strong> </p>
<p><strong>2.  只有v7 onTouchEvent DOWN事件返回true</strong></p>
<p><strong>3.  只有v7处理事件，但是vp4在屏幕下半部分拦截MOVE事件</strong></p>
<p>自定义MyView  </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context, attrs: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : View(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> mOnTouchValue = <span class="literal">false</span><span class="comment">//是否分发事件</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.KITKAT)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;MyView&quot;</span>, <span class="string">&quot;<span class="variable">$name</span> onTouchEvent <span class="subst">$&#123;MotionEvent.actionToString(event.action)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mOnTouchValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义MyFrameLayout</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrameLayout</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context, attrs: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : FrameLayout(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> mOnTouchValue = <span class="literal">false</span><span class="comment">//是否分发事件</span></span><br><span class="line">    <span class="keyword">var</span> mDispatchValueSuper = <span class="literal">true</span> <span class="comment">//是否调用super.dispatchTouchEvent,如果false 直接return true</span></span><br><span class="line">    <span class="keyword">var</span> mRegionInterceptor = <span class="literal">false</span><span class="comment">//在某个特定区域 拦截事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchTouchEvent</span><span class="params">(ev: <span class="type">MotionEvent</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (mDispatchValueSuper) &#123;</span><br><span class="line">            <span class="keyword">super</span>.dispatchTouchEvent(ev)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.KITKAT)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInterceptTouchEvent</span><span class="params">(ev: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;MyFrameLayout&quot;</span>, <span class="string">&quot;<span class="variable">$name</span> onInterceptTouchEvent <span class="subst">$&#123;MotionEvent.actionToString(ev.action)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mRegionInterceptor) &#123;</span><br><span class="line">            <span class="keyword">val</span> touchY = ev?.y</span><br><span class="line">            <span class="keyword">if</span> (touchY != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (touchY &gt; measuredHeight / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onInterceptTouchEvent(ev)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.KITKAT)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTouchEvent</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;MyFrameLayout&quot;</span>, <span class="string">&quot;<span class="variable">$name</span> onTouchEvent <span class="subst">$&#123;MotionEvent.actionToString(event.action)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (mOnTouchValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景一 所有的View都不分发事件，所有的ViewGroup都不拦截事件</strong>  </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TouchOneActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"><span class="comment">//        setContentView(R.layout.activity_touch_one)</span></span><br><span class="line">        <span class="comment">//所有的view都不分发事件</span></span><br><span class="line">        <span class="keyword">val</span> view1 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view2 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view3 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> vp2 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp2.addView(view1)</span><br><span class="line">        vp2.addView(view2)</span><br><span class="line">        vp2.addView(view3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> view4 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view5 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view6 = MyView(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> vp3 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp3.addView(view4)</span><br><span class="line">        vp3.addView(view5)</span><br><span class="line">        vp3.addView(view6)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> view7 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view8 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view9 = MyView(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> vp4 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp4.addView(view7)</span><br><span class="line">        vp4.addView(view8)</span><br><span class="line">        vp4.addView(view9)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> vp1 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp1.addView(vp2)</span><br><span class="line">        vp1.addView(vp3)</span><br><span class="line">        vp1.addView(vp4)</span><br><span class="line"></span><br><span class="line">        setContentView(vp1)</span><br><span class="line">        view1.name = <span class="string">&quot;view1&quot;</span></span><br><span class="line">        view2.name = <span class="string">&quot;view2&quot;</span></span><br><span class="line">        view3.name = <span class="string">&quot;view3&quot;</span></span><br><span class="line">        view4.name = <span class="string">&quot;view4&quot;</span></span><br><span class="line">        view5.name = <span class="string">&quot;view5&quot;</span></span><br><span class="line">        view6.name = <span class="string">&quot;view6&quot;</span></span><br><span class="line">        view7.name = <span class="string">&quot;view7&quot;</span></span><br><span class="line">        view8.name = <span class="string">&quot;view8&quot;</span></span><br><span class="line">        view9.name = <span class="string">&quot;view9&quot;</span></span><br><span class="line">        vp1.name =<span class="string">&quot;vp1&quot;</span></span><br><span class="line">        vp2.name =<span class="string">&quot;vp2&quot;</span></span><br><span class="line">        vp3.name =<span class="string">&quot;vp3&quot;</span></span><br><span class="line">        vp4.name =<span class="string">&quot;vp4&quot;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志打印如下  </p>
<blockquote>
<blockquote>
<p>Vp1 onInterceptTouchEvent  Down</p>
<p>Vp4 onInterceptTouchEvent  Down</p>
<p>V9 onTouchEvent  Down</p>
<p>V8 onTouchEvent  Down</p>
<p>V7 onTouchEvent  Down</p>
<p>Vp4 onTouchEvent  Down</p>
<p>Vp3 onInterceptTouchEvent  Down</p>
<p>V6 onTouchEvent  Down</p>
<p>V5 onTouchEvent  Down</p>
<p>V4 onTouchEvent  Down</p>
<p>Vp3 onTouchEvent  Down</p>
<p>Vp2onInterceptTouchEvent  Down</p>
<p>V3 onTouchEvent  Down</p>
<p>V2 onTouchEvent  Down</p>
<p>V1 onTouchEvent  Down</p>
<p>Vp2 onTouchEvent  Down</p>
<p>Vp1 onTouchEvent  Down </p>
</blockquote>
</blockquote>
<p>分发图如下  </p>
<p><img src="https://cdn.jsdelivr.net/gh/lizijin/bytestation@master/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/byte_station_DOWN%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%911.jpeg" alt="DOWN事件分发图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizijin/bytestation@master/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/byte_station_MOVE%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%911.jpeg" alt="MOVE事件分发图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizijin/bytestation@master/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/byte_station_UP%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%911.jpeg" alt="UP事件分发图"> </p>
<p><strong>场景二 只有v7 onTouchEvent DOWN事件返回true</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TouchTwoActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_touch_two)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//View 7 分发事件</span></span><br><span class="line">        <span class="keyword">val</span> view1 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view2 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view3 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> vp2 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp2.addView(view1)</span><br><span class="line">        vp2.addView(view2)</span><br><span class="line">        vp2.addView(view3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> view4 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view5 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view6 = MyView(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> vp3 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp3.addView(view4)</span><br><span class="line">        vp3.addView(view5)</span><br><span class="line">        vp3.addView(view6)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> view7 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        view7.mOnTouchValue = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">val</span> view8 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view9 = MyView(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> vp4 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp4.addView(view7)</span><br><span class="line">        vp4.addView(view8)</span><br><span class="line">        vp4.addView(view9)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> vp1 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp1.addView(vp2)</span><br><span class="line">        vp1.addView(vp3)</span><br><span class="line">        vp1.addView(vp4)</span><br><span class="line"></span><br><span class="line">        setContentView(vp1)</span><br><span class="line">        view1.name = <span class="string">&quot;view1&quot;</span></span><br><span class="line">        view2.name = <span class="string">&quot;view2&quot;</span></span><br><span class="line">        view3.name = <span class="string">&quot;view3&quot;</span></span><br><span class="line">        view4.name = <span class="string">&quot;view4&quot;</span></span><br><span class="line">        view5.name = <span class="string">&quot;view5&quot;</span></span><br><span class="line">        view6.name = <span class="string">&quot;view6&quot;</span></span><br><span class="line">        view7.name = <span class="string">&quot;view7&quot;</span></span><br><span class="line">        view8.name = <span class="string">&quot;view8&quot;</span></span><br><span class="line">        view9.name = <span class="string">&quot;view9&quot;</span></span><br><span class="line">        vp1.name =<span class="string">&quot;vp1&quot;</span></span><br><span class="line">        vp2.name =<span class="string">&quot;vp2&quot;</span></span><br><span class="line">        vp3.name =<span class="string">&quot;vp3&quot;</span></span><br><span class="line">        vp4.name =<span class="string">&quot;vp4&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志打印如下  </p>
<blockquote>
<blockquote>
<p>Vp1 onInterceptTouchEvent  Down</p>
<p>Vp4 onInterceptTouchEvent  Down</p>
<p>v9 onTouchEvent  Down</p>
<p>v8 onTouchEvent  Down</p>
<p>v7 onTouchEvent  Down  # v7消耗掉了事件，中断本层遍历，并回溯设置ft</p>
<p>Vp1 onInterceptTouchEvent  Move</p>
<p>Vp4 onInterceptTouchEvent  Move</p>
<p>v7 onTouchEvent  Move</p>
<p>Vp1 onInterceptTouchEvent  UP</p>
<p>Vp4 onInterceptTouchEvent  UP</p>
<p>v7 onTouchEvent  UP  </p>
</blockquote>
</blockquote>
<p>分发图如下  </p>
<p>DOWN事件分发图如下。步骤6、7是逻辑。并非实际打印</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizijin/bytestation@master/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/byte_station_Down%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%912.jpeg" alt="DOWN事件分发图"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizijin/bytestation@master/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/byte_station_move%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%912.jpeg" alt="MOVE事件分发图">  </p>
<p><strong>场景三 只有v7处理事件，但是vp1在屏幕下半部分拦截MOVE事件</strong><br>场景三事件分发比较复杂。因为在ft不为空的ViewGroup上拦截事件会分发CANCEL事件</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TouchFourActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_touch_two)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//View 7 分发事件 但是vp1在屏幕下半部分拦截move事件 从上往下滑动</span></span><br><span class="line">        <span class="keyword">val</span> view1 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view2 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view3 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> vp2 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp2.addView(view1)</span><br><span class="line">        vp2.addView(view2)</span><br><span class="line">        vp2.addView(view3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> view4 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view5 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view6 = MyView(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> vp3 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp3.addView(view4)</span><br><span class="line">        vp3.addView(view5)</span><br><span class="line">        vp3.addView(view6)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> view7 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        view7.mOnTouchValue = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">val</span> view8 = MyView(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">val</span> view9 = MyView(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> vp4 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp4.addView(view7)</span><br><span class="line">        vp4.addView(view8)</span><br><span class="line">        vp4.addView(view9)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> vp1 = MyFrameLayout(<span class="keyword">this</span>)</span><br><span class="line">        vp1.addView(vp2)</span><br><span class="line">        vp1.addView(vp3)</span><br><span class="line">        vp1.addView(vp4)</span><br><span class="line"></span><br><span class="line">        setContentView(vp1)</span><br><span class="line">        view1.name = <span class="string">&quot;view1&quot;</span></span><br><span class="line">        view2.name = <span class="string">&quot;view2&quot;</span></span><br><span class="line">        view3.name = <span class="string">&quot;view3&quot;</span></span><br><span class="line">        view4.name = <span class="string">&quot;view4&quot;</span></span><br><span class="line">        view5.name = <span class="string">&quot;view5&quot;</span></span><br><span class="line">        view6.name = <span class="string">&quot;view6&quot;</span></span><br><span class="line">        view7.name = <span class="string">&quot;view7&quot;</span></span><br><span class="line">        view8.name = <span class="string">&quot;view8&quot;</span></span><br><span class="line">        view9.name = <span class="string">&quot;view9&quot;</span></span><br><span class="line">        vp1.name =<span class="string">&quot;vp1&quot;</span></span><br><span class="line">        vp2.name =<span class="string">&quot;vp2&quot;</span></span><br><span class="line">        vp3.name =<span class="string">&quot;vp3&quot;</span></span><br><span class="line">        vp4.name =<span class="string">&quot;vp4&quot;</span></span><br><span class="line">        vp1.mRegionInterceptor=<span class="literal">true</span><span class="comment">//下半屏幕拦截事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志打印如下  </p>
<blockquote>
<blockquote>
<p>vp1 onInterceptTouchEvent ACTION_DOWN  </p>
<p>vp4 onInterceptTouchEvent ACTION_DOWN  </p>
<p>view9 onTouchEvent ACTION_DOWN </p>
<p>view8 onTouchEvent ACTION_DOWN  </p>
<p>view7 onTouchEvent ACTION_DOWN </p>
<p>vp1 onInterceptTouchEvent ACTION_MOVE  </p>
<p>vp4 onInterceptTouchEvent ACTION_MOVE  </p>
<p>view7 onTouchEvent ACTION_MOVE </p>
<p>vp1 onInterceptTouchEvent ACTION_MOVE  </p>
<p>vp4 onInterceptTouchEvent ACTION_MOVE  </p>
<p>view7 onTouchEvent ACTION_MOVE  </p>
<p>vp1 onInterceptTouchEvent ACTION_MOVE  </p>
<p>vp4 onInterceptTouchEvent ACTION_MOVE  </p>
<p>view7 onTouchEvent ACTION_MOVE  </p>
<p>vp1 onInterceptTouchEvent ACTION_MOVE  </p>
<p>vp4 onInterceptTouchEvent ACTION_MOVE  </p>
<p>view7 onTouchEvent ACTION_MOVE  </p>
<p>vp1 onInterceptTouchEvent ACTION_MOVE  </p>
<p>vp4 onInterceptTouchEvent ACTION_MOVE  </p>
<p>view7 onTouchEvent ACTION_MOVE  </p>
<p>vp1 onInterceptTouchEvent ACTION_MOVE  </p>
<p>vp4 onInterceptTouchEvent ACTION_MOVE  </p>
<p>view7 onTouchEvent ACTION_MOVE  </p>
<p>vp1 onInterceptTouchEvent ACTION_MOVE//此时移动到了屏幕下方  </p>
<p>vp4 onInterceptTouchEvent ACTION_CANCEL  </p>
<p>view7 onTouchEvent ACTION_CANCEL  </p>
<p>vp1 onTouchEvent ACTION_MOVE  </p>
<p>vp1 onTouchEvent ACTION_MOVE  </p>
<p>vp1 onTouchEvent ACTION_MOVE  </p>
<p>vp1 onTouchEvent ACTION_MOVE  </p>
<p>vp1 onTouchEvent ACTION_UP</p>
</blockquote>
</blockquote>
<p>在屏幕上半部分滑动事件分发图同场景二</p>
<p>在屏幕下半部分滑动分发图如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/lizijin/bytestation@master/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/byte_station_Move%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%913.jpeg" alt="MOVE事件在屏幕下方被拦截"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizijin/bytestation@master/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/byte_station_move-up.jpeg" alt="后续MOVE、UP事件分发"></p>
<p>后续的MOVE和UP都只会分发到vp1的onTouchEvent方法里。因为vp1.parent的ft不为空。vp1的ft为空。<br>Android事件分发比较复杂。建议读者不要走马观花的看本篇文件。可以将树形图画在草稿本上。然后结合源码。挨个练习DOWN、MOVE、UP、CANCEL事件分发的流程。  </p>
<hr>
<h4 id="Written-By-多点-移动运营研发部-姜斌"><a href="#Written-By-多点-移动运营研发部-姜斌" class="headerlink" title="Written By 多点-移动运营研发部-姜斌"></a>Written By 多点-移动运营研发部-姜斌</h4><p>如果你有任何问题，欢迎通过以下方式联系我<br><img src="https://cdn.jsdelivr.net/gh/lizijin/bytestation@master/byte_station_%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpeg" alt="欢迎扫码关注公众号"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lizijin/bytestation@master/byte_station_%E5%BE%AE%E4%BF%A1%E5%A5%BD%E5%8F%8B.jpeg" alt="欢迎扫码加微信好友"></p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>KVC实现原理分析</title>
    <url>/2021/05/19/KVC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="KVC实现原理分析"><a href="#KVC实现原理分析" class="headerlink" title="KVC实现原理分析"></a>KVC实现原理分析</h2><h3 id="问题？"><a href="#问题？" class="headerlink" title="问题？"></a>问题？</h3><ol>
<li>KVC在进行存取的时候，是怎么进行查找赋值的？</li>
<li>KVC的keypath中集合运算符是如何使用的？</li>
<li>使用KVC的时候如果setvalue的属性没有实现会怎样？</li>
</ol>
<h3 id="KVC是什么？"><a href="#KVC是什么？" class="headerlink" title="KVC是什么？"></a>KVC是什么？</h3><ul>
<li>KVC全称是Key value coding，定义在NSKeyValueCoding.h文件中，是一个非正式协议。</li>
<li>KVC提供了一种间接访问属性方法/成员变量的机制。我们可以通过字符串来访问对应的属性方法或者成员变量。</li>
<li>KVC的实现依赖其搜索规则。</li>
</ul>
<h3 id="KVC的访问方法"><a href="#KVC的访问方法" class="headerlink" title="KVC的访问方法"></a>KVC的访问方法</h3><ul>
<li>在NSKeyValueCoding中我们可以看到提供了KVC的通用访问方法，getter方法：valueForKey:以及setter方法：setValue:forKey，以及其衍生出来的keyPath方法。</li>
<li>这两个方法由KVC提供了默认的实现。也可以重写对应的方法来更改实现。</li>
</ul>
<h3 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h3><p>KVC主要针对三种类型进行操作，基础数据类型，对象和集合类型。</p>
<h3 id="KVC的集合操作符运算"><a href="#KVC的集合操作符运算" class="headerlink" title="KVC的集合操作符运算"></a>KVC的集合操作符运算</h3><ul>
<li>@sum 求和运算 比如@sum.classNumber</li>
<li>@avg 求平均值运算 比如@avg.classNumber</li>
<li>@count 求集合中元素的个数 比如@count</li>
</ul>
<h3 id="搜索规则"><a href="#搜索规则" class="headerlink" title="搜索规则"></a>搜索规则</h3><ul>
<li>KVC在通过key和keypath进行操作的时候，可以查找属性方法，成员变量。查找的时候可以兼容多种命名，查找的规则官方文档有介绍。</li>
<li>在KVC的实现中，依赖了<code>setter</code>和<code>getter</code>方法的实现。方法的命名要符合apple的规范。</li>
</ul>
<h4 id="关键属性accessInstanceVariablesDirectly"><a href="#关键属性accessInstanceVariablesDirectly" class="headerlink" title="关键属性accessInstanceVariablesDirectly"></a>关键属性accessInstanceVariablesDirectly</h4><p>这个属性表示是否允许读取实例变量的值，如果设置为YES,表明在KVC的查找中，从内存中读取实例变量的值。（在没有找到存取器的时候才会调用该方法）。</p>
<h3 id="基础getter搜索模式"><a href="#基础getter搜索模式" class="headerlink" title="基础getter搜索模式"></a>基础getter搜索模式</h3><ol>
<li>这种搜索模式是valueForKey:的默认实现，给定一个key作为参数</li>
<li>通过<code>getter</code>方法搜索实例，依次匹配  <code>get&lt;key&gt;</code>  <code>&lt;key&gt; </code> <code>is&lt;key&gt;</code> <code> _&lt;key&gt;</code> 如果找到，直接返回。需要注意的是：如果返回的是对象指针类型，直接返回结果，如果返回的是NSNumber转化所支持的变量之一，返回一个NSNumber否则返回的是NSValue。</li>
<li>当没有找到getter方法的时候，调用<code>accessInstanceVariablesDirectly</code>询问，如果返回<code>yes</code>，从<code>_&lt;key&gt;`` _is&lt;key&gt;</code> <code>&lt;key&gt;</code> <code>is&lt;key&gt;</code>中查找对应的值。如果返回NO结束查找，并调用<code>valueForUndefindedKey</code>异常。</li>
</ol>
<h3 id="基础setter搜索模式"><a href="#基础setter搜索模式" class="headerlink" title="基础setter搜索模式"></a>基础setter搜索模式</h3><ol>
<li>这种搜索模式是<code>setValue:forKey</code>的默认实现，给定输入的value和key。在调用对象的内部，设置属性名为key的<code>value</code>。</li>
<li>查找<code>set&lt;key&gt;:</code>或者<code>_set&lt;key&gt;</code>命名的setter。按照这个顺序，如果找到的话，调用这个方法执行。</li>
<li>如果设置的<code>setter</code>但是<code>accessInstanceVariablesDirectly</code>返回YES,那么查找的命名规则为<code>_&lt;key&gt; _is&lt;key&gt; &lt;key&gt; is&lt;key&gt;</code>的实例变量。根据这个顺序将value赋值给实例变量。</li>
<li>如果没有发现setter或实例变量。调用<code>setValueForUndefinedKey</code>并抛出异常。</li>
</ol>
<h3 id="KVC的性能"><a href="#KVC的性能" class="headerlink" title="KVC的性能"></a>KVC的性能</h3><p>从上面的描述中可以看出：KVC的性能访问属性并没有直接访问快，因为他是按照搜索规则进行搜索。所以我们在使用的时候，最好不 要手动设置<code>setter``和getter</code> 方法这样会导致搜索的步骤变长。本质上是操作方法列表以及在内存中去查找实例变量。这个操作对readonly和protected的成员变量，都可以正常访问。如果不想在外界访问的话，可以将<code>accessInstanceVariableDirectly</code>设置为NO。</p>
<h3 id="KVC缺点"><a href="#KVC缺点" class="headerlink" title="KVC缺点"></a>KVC缺点</h3><ul>
<li>因为我们在操作的时候传入<code>setvalueForKey</code>以及<code>setvalueForKeyPath valueForKey</code>以及<code>keyPath</code>是一个字符串。编译器在编译的时候不会报错，但是在运行的时候，如果设置或者获取的属性不存在就会报undefinedKey异常。</li>
<li>例如：在 iOS13之前我们可以通过改变私有变量的属性来更改一些设置。比如更改textField的颜色属性。iOS13之后更改的时候debug模式下会crash。</li>
</ul>
<h3 id="JsonModel中的使用"><a href="#JsonModel中的使用" class="headerlink" title="JsonModel中的使用"></a>JsonModel中的使用</h3><p>主要是通过KVC进行赋值，例如在赋值的时候，循环遍历model中每一个解析出来的property结构，从dic中拿出对应的value，进行一系列的判断。如果value可用，就进行赋值。如果对应的property是一个jsonmodel的时候，就递归先将子model进行整理解析。如果包含protocol字段，表明是一个array或者dictionary。然后将这个protocol字段的对象解析。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>RunLoop实现原理分析</title>
    <url>/2021/05/19/Runloop%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>RunLoop是通过内部维护的事件循环(Event Loop)来对事件/消息进行管理的一个对象。App主线程不退出就是用到了Event Loop。</p>
<ul>
<li>保持程序持续运行</li>
<li>监听输入源，进行调度处理app各种事件（touch/timer/performSelector/异步回调）</li>
<li>节省cpu资源</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gietsitlo3j31l60t41kx.jpg" alt="截屏2020-09-03 上午9.15.01"></p>
<p>RunLoop 会接收两种类型的输入源：一种是来自另一个线程或者来自不同应用的异步消息；另一种是来自预订时间或者重复间隔的同步事件。</p>
<blockquote>
<p>macOS/iOS系统中提供了两个对象：<strong>NSRunLoop</strong>和<strong>CFRunLoopRef</strong>。</p>
<ul>
<li><strong>CFRunLoopRef</strong>在<strong>CoreFoundation</strong>框架中，提供了纯C函数的API，并且所有API都是<strong>线程安全</strong>的。</li>
<li><strong>NSRunLoop</strong>则是基于<strong>CFRunLoopRef</strong>的封装，提供面向对象的API，但是这些API是<strong>非线程安全</strong>的。</li>
</ul>
</blockquote>
<h4 id="和线程关系"><a href="#和线程关系" class="headerlink" title="和线程关系"></a>和线程关系</h4><ul>
<li><p>线程和RunLoop是一一对应的,其映射关系是保存在一个全局的 Dictionary 里</p>
</li>
<li><p>自己创建的线程默认是没有开启RunLoop的</p>
</li>
<li><p>UIApplicationMain内部默认开启了主线程的RunLoop，不断地接收处理消息以及等待休眠，所以运行程序之后会保持持续运行状态。</p>
<p>线程和runloop映射关系关键代码如下（<a href="https://opensource.apple.com/tarballs/CF/">Runloop源码</a>）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">    CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br></pre></td></tr></table></figure>



<h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><p>内部结构如下： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">pthread_t</span> _pthread;                  <span class="comment">//持有的线程对象             </span></span><br><span class="line">    CFMutableSetRef  _commonModes;       <span class="comment">//模式名称字符串集合</span></span><br><span class="line">    CFMutableSetRef  _commonModeItems;   <span class="comment">//由Observer,Timer,Source集合构成</span></span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef  _modes;             <span class="comment">//多个运行模式集合</span></span><br><span class="line">		...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    CFStringRef _name;                   <span class="comment">//// Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span></span><br><span class="line">    CFMutableSetRef _sources0;           <span class="comment">//处理APP内部事件，APP自己负责，管理触发</span></span><br><span class="line">    CFMutableSetRef _sources1;           <span class="comment">//由runloop和内核管理，包含一个  mach_port（处理端口类的消息）和一个回调（函数指针），被用于通过内核和其他线程互发消息，这种source能主动唤醒runloop的线程</span></span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>CommonModes</strong>：一个<code>Mode</code>可以将自己标记为<code>Common</code>属性（通过将其<code>ModeName</code>添加到<code>RunLoop</code>的<code>commonModes</code>中）。每当<code>RunLoop</code>的内容发生变化时，<code>RunLoop</code>都会自动将 <code>_commonModeItems</code>里的<code>Source/Observer/Timer</code>同步到具有<code>Common</code>标记的所有<code>Mode</code>里。</p>
<blockquote>
<p>主线程的<code>RunLoop</code>里有两个公开预置的<code>Mode</code>,可以用这两个<code>Mode Name</code>来操作其对应的<code>Mode</code>：</p>
<ul>
<li><code>kCFRunLoopDefaultMode</code></li>
<li><code>UITrackingRunLoopMode</code></li>
</ul>
<p>这两个<code>Mode</code>都已经被标记为<code>Common</code>属性。<code>DefaultMode</code>是App平时所处的状态，<code>TrackingRunLoopMode</code>是追踪ScrollView滑动时的状态。当你创建一个<code>Timer</code>并加到<code>DefaultMode</code>时，<code>Timer</code>会得到重复回调，但此时滑动一个TableView时，<code>RunLoop</code>会将<code>mode</code>切换为<code>TrackingRunLoopMode</code>，这时<code>Timer</code>就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个<code>Timer</code>，在两个<code>Mode</code>中都能得到回调，一种办法就是将这个<code>Timer</code>分别加入这两个<code>Mode</code>。还有一种方式，就是将<code>Timer</code>加入到顶层的<code>RunLoop</code>的<code>commonModeItems</code>中。<code>commonModeItems</code>被<code>RunLoop</code>自动更新到所有具有<code>Common</code>属性的<code>Mode</code>里去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="CFRunLoopMode-CFRunLoopModeRef"><a href="#CFRunLoopMode-CFRunLoopModeRef" class="headerlink" title="CFRunLoopMode(CFRunLoopModeRef)"></a>CFRunLoopMode(CFRunLoopModeRef)</h4><p>总共是有五种<code>CFRunLoopMode</code>:</p>
<ul>
<li><code>kCFRunLoopDefaultMode</code>：默认模式，主线程是在这个运行模式下运行</li>
<li><code>UITrackingRunLoopMode</code>：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li>
<li><code>UIInitializationRunLoopMode</code>：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用</li>
<li><code>GSEventReceiveRunLoopMode</code>：接受系统内部事件，通常用不到</li>
<li><code>kCFRunLoopCommonModes</code>：伪模式，不是一种真正的运行模式，是同步Source/Timer/Observer到多个Mode中的一种解决方案</li>
</ul>
<p>一个RunLoop 对象中可能包含多个Mode，每次调用 RunLoop 的主函数时，只能指定其中一个 Mode(CurrentMode)。切换 Mode需要退出loop重新指定一个 Mode进入 。主要是为了分隔开不同的 Source、Timer、Observer，让它们之间互不影响。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gietsxahcdj31gk0s4dj9.jpg" alt="截屏2020-09-03 上午9.15.40"></p>
<h5 id="CFRunLoopSource"><a href="#CFRunLoopSource" class="headerlink" title="CFRunLoopSource"></a>CFRunLoopSource</h5><p>分为source0和source1两种</p>
<ul>
<li><p>sources0 :用户触发的事件。不能主动触发事件，需要手动唤醒线程，将当前线程从内核态切换到用户态。</p>
<p>使用时，需要先调用<code>CFRunLoopSourceSignal(source)</code>，将这个<code>Source</code>标记为待处理，然后手动调用<code>CFRunLoopWakeUp(runloop)</code>来唤醒<code>RunLoop</code>，让其处理这个事件。</p>
</li>
<li><p>sources1 :基于port的，包含一个 mach_port 和一个回调，可监听系统端口和通过内核和其他线程发送的消息，能主动唤醒RunLoop，接收分发系统事件</p>
</li>
</ul>
<h5 id="CFRunLoopTimer"><a href="#CFRunLoopTimer" class="headerlink" title="CFRunLoopTimer"></a>CFRunLoopTimer</h5><p>在预设的时间点唤醒RunLoop执行回调。基于RunLoop的，因此它不是实时的.</p>
<blockquote>
<p>CADisplayLink 是一个用于显示的定时器， 它可以让用户程序的显示与屏幕的硬件刷新保持同步，iOS系统中正常的屏幕刷新率为60Hz（60次每秒）。</p>
<p>FPS监测就是利用屏幕刷新的频率调用CADisplayLink指定的selector，就是说每次屏幕刷新的时候就调用selector，那么只要在selector方法里面统计每秒这个方法执行的次数，通过次数/时间就可以得出当前屏幕的刷新率了。</p>
</blockquote>
<h5 id="CFRunLoopObserver"><a href="#CFRunLoopObserver" class="headerlink" title="CFRunLoopObserver"></a>CFRunLoopObserver</h5><p>包含了一个回调(函数指针)，当<code>RunLoop</code>的状态发生变化时，观察者就能通过回调接受到这个变化。</p>
<p>可以观测的时间点有以下几个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1UL</span> &lt;&lt; <span class="number">0</span>),         <span class="comment">//RunLoop准备启动，即将进入loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1UL</span> &lt;&lt; <span class="number">1</span>),  <span class="comment">//触发 Timer 回调，RunLoop将要处理一些Timer相关事件</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1UL</span> &lt;&lt; <span class="number">2</span>), <span class="comment">//触发 Source0 回调，RunLoop将要处理一些Source事件</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">5</span>), <span class="comment">//等待 mach_port 消息，RunLoop将要进行休眠状态,即将由用户态切换到内核态</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1UL</span> &lt;&lt; <span class="number">6</span>),  <span class="comment">//接收 mach_port 消息，RunLoop被唤醒，即从内核态切换到用户态</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1UL</span> &lt;&lt; <span class="number">7</span>),          <span class="comment">//RunLoop退出</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U <span class="comment">//监听所有状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的<code>Source/Timer/Observer</code>被统称为 <strong>mode item</strong>，一个<code>item</code>可以被同时加入多个<code>mode</code>。如果一个<code>mode</code>中一个<code>item</code>都没有，则<code>RunLoop</code>会直接退出，不进入<code>Loop</code>。</p>
<p><code>CFRunLoop</code>对外暴露的管理 Mode 接口只有下面2个:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>

<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line"></span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line"></span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure>

<p><code>mode</code>并不像<code>Source/Timer/Observer</code>一样有 Remove 方法，所以<code>mode</code>只能增加，不能减少。你只能通过 <code>modeName</code> 来操作内部的 mode，当你传入一个新的<code>modeName</code> 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 <code>CFRunLoopModeRef</code>。</p>
<h3 id="三、内部实现"><a href="#三、内部实现" class="headerlink" title="三、内部实现"></a>三、内部实现</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1giettavhy8j30xc0poahf.jpg" alt="3344530-0f941859d3fbd597"></p>
<p>大致逻辑为：<br>1、通知observers RunLoop 即将启动。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **1.通知Observers：RunLoop即将进入loop</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    <span class="comment">//进入loop循环</span></span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br></pre></td></tr></table></figure>

<p>开启一个 do while 来保活线程.</p>
<p>2、通知观察者即将要处理Timer事件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通知 Observers RunLoop 会触发 Timer 回调</span></span><br><span class="line"><span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeTimers)</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br></pre></td></tr></table></figure>

<p>3、通知观察者即将要处理source0事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通知 Observers RunLoop 会触发 Source0 回调</span><br><span class="line">if (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeSources)</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">    // 执行 block</span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br></pre></td></tr></table></figure>

<p>4、处理source0事件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RunLoop触发Source0(非port)回调</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br></pre></td></tr></table></figure>

<p>5、如果基于端口的源(Source1)准备好并处于等待状态，进入步骤9。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg,       <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、通知观察者线程即将进入休眠状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Boolean poll = sourceHandledThisLoop || (<span class="number">0ULL</span> == timeout_context-&gt;termTSR);</span><br><span class="line"><span class="keyword">if</span> (!poll &amp;&amp; (currentMode-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) &#123;</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、将线程置于休眠状态，由用户态切换到内核态，直到下面的任一事件发生才唤醒线程。</p>
<ul>
<li><p>一个基于 port 的Source1 的事件。</p>
</li>
<li><p>Timer 时间到了。</p>
</li>
<li><p>RunLoop超时。</p>
</li>
<li><p>被其他调用者手动唤醒。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">        <span class="comment">// 基于 port 的 Source 事件、调用者唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Timer 时间到、RunLoop 超时</span></span><br><span class="line">        <span class="keyword">if</span> (currentMode-&gt;_timerFired) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>8、通知观察者线程将被唤醒。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!poll &amp;&amp; (currentMode-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br></pre></td></tr></table></figure>

<p>9、处理唤醒时收到的事件。</p>
<ul>
<li><p>如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2。</p>
</li>
<li><p>如果输入源启动，传递相应的消息。</p>
</li>
<li><p>如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">handle_msg:</span><br><span class="line"><span class="comment">// 如果 Timer 时间到，就触发 Timer 回调</span></span><br><span class="line"><span class="keyword">if</span> (msg-is-timer) &#123;</span><br><span class="line">    __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果 dispatch 就执行 block</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">    __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Source1 事件的话，就处理这个事件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">    sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">    <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">        mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>判断当前RunLoop状态值，是否停止或继续下一个loop。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">     // 事件已处理完</span><br><span class="line">    retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">&#125; else if (timeout) &#123;</span><br><span class="line">    // 超时</span><br><span class="line">    retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">&#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">    // 外部调用者强制停止</span><br><span class="line">    retVal = kCFRunLoopRunStopped;</span><br><span class="line">&#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">    // mode 为空，RunLoop 结束</span><br><span class="line">    retVal = kCFRunLoopRunFinished;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、通知观察者RunLoop结束</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **10.通知Observers：RunLoop即将退出loop</span></span><br><span class="line">    <span class="keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">        __CFRunLoopModeUnlock(currentMode);</span><br><span class="line">        __CFRunLoopPopPerRunData(rl, previousPerRun);</span><br><span class="line">    rl-&gt;_currentMode = previousMode;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br></pre></td></tr></table></figure>

<p>整个流程如下图：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1giettlm3udj31hc0u00x8.jpg" alt="5f51c5e05085badb689f01b1e63e1c7d"></p>
<h2 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h2><h4 id="监测卡顿"><a href="#监测卡顿" class="headerlink" title="监测卡顿"></a>监测卡顿</h4><p>导致卡顿问题主要几个原因：</p>
<ul>
<li>复杂 UI 、图文混排的绘制量过大；</li>
<li>在主线程上做网络同步请求；</li>
<li>在主线程做大量的 IO 操作；</li>
<li>运算量过大，CPU 持续高占用；</li>
<li>死锁和主子线程抢锁。</li>
</ul>
<p>线程的消息事件是依赖于 NSRunLoop 的，所以从 NSRunLoop 入手，就可以知道主线程上都调用了哪些方法。我们通过监听 NSRunLoop 的6种状态，就能够发现调用方法是否执行时间过长，从而判断出是否会出现卡顿。</p>
<p>如果 RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。</p>
<p>所以，如果我们要利用 RunLoop 原理来监控卡顿的话，就是要关注这两个阶段。RunLoop 在进入睡眠之前和唤醒后的两个 loop 状态定义的值，分别是 <code>kCFRunLoopBeforeSources </code>（触发 Source0 回调，RunLoop将要处理一些Source事件）和 <code>kCFRunLoopAfterWaiting</code> （接收 mach_port 消息，RunLoop被唤醒，即从内核态切换到用户态），也就是要触发 Source0 回调和接收 mach_port 消息两个状态。</p>
<blockquote>
<p>监测FPS也可以粗略监测卡顿，FPS 是一秒显示的帧数，也就是一秒内画面变化数量。</p>
<p>人眼在24帧就感觉还是很流畅，感受不到卡顿，所以通过FPS监控卡顿不太合适。</p>
</blockquote>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>创建一个观察者 runLoopObserver 添加到主线程 RunLoop 的 common 模式下观察。</p>
<p>然后，创建一个持续的子线程专门用来监控主线程的 RunLoop 状态。</p>
<p>一旦发现进入睡眠前的 kCFRunLoopBeforeSources 状态，或者唤醒后的状态 kCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判定为卡顿。接下来，我们就可以打印堆栈的信息。</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> semaphoreWait = dispatch_semaphore_wait(dispatchSemaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span> * NSEC_PER_SEC));</span><br></pre></td></tr></table></figure>

<p>NSEC_PER_SEC，代表的是触发卡顿的时间阈值，单位是秒,这里设置成3s。</p>
<p>触发卡顿的时间阈值根据 WatchDog 机制来设置.</p>
<p>WatchDog 在不同状态下设置的不同时间，如下所示：启动（Launch）：20s；恢复（Resume）：10s；挂起（Suspend）：10s；退出（Quit）：6s；后台（Background）：3min（在 iOS 7 之前，每次申请 10min； 之后改为每次申请 3min，可连续申请，最多申请到 10min）。</p>
<p>通过 WatchDog 设置的时间，可以把启动的阈值设置为 10 秒，其他状态则都默认设置为 3 秒。总的原则就是，要小于 WatchDog 的限制时间。这个阈值也不用小得太多，原则就是要优先解决用户感知最明显的体验问题。</p>
</blockquote>
<h2 id="五、底层实现"><a href="#五、底层实现" class="headerlink" title="五、底层实现"></a>五、底层实现</h2><p>RunLoop在没有消息处理时，休眠已避免资源占用，由用户态切换到内核态(CPU-内核态和用户态)；当有消息需要处理时，立刻被唤醒，由内核态切换到用户态。</p>
<p><code>RunLoop</code>的核心是基于<code>mach port</code>的，其进入休眠时调用的函数是<code>mach_msg()</code>。</p>
<p>内核态：系统中既有操作系统的程序，也由普通用户的程序。为了安全和稳定性操作系统的程序不能随便访问,这就是内核态,内核态可以使用所有的硬件资源<br>用户态：不能直接使用系统资源，也不能改变CPU的工作状态，并且只能访问这个用户程序自己的存储空间</p>
<p>RunLoop这个机制是依靠系统内核来完成。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gietu0neptj30rw0i2acx.jpg" alt="1782258-e344f28cdf417b49"></p>
<blockquote>
<p>深入了解可以参考如下文章：</p>
<p> <a href="https://nshipster.com/inter-process-communication/">mach port使用</a>（<a href="https://segmentfault.com/a/1190000002400329">中文</a>）</p>
<p><a href="https://segmentfault.com/a/1190000002400329">Mach</a></p>
</blockquote>
<h2 id="六、文章参考"><a href="#六、文章参考" class="headerlink" title="六、文章参考"></a>六、文章参考</h2><blockquote>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a></p>
</blockquote>
<h4 id="Written-By-多点-移动运营研发部-白迎春"><a href="#Written-By-多点-移动运营研发部-白迎春" class="headerlink" title="Written By 多点-移动运营研发部-白迎春"></a>Written By 多点-移动运营研发部-白迎春</h4>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用说明</title>
    <url>/2021/05/19/hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<p>// submit &amp; preview<br>hexo g &amp;&amp; hexo s</p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>iOS动画小结</title>
    <url>/2021/05/19/iOS%E5%8A%A8%E7%94%BB%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="iOS动画小结"><a href="#iOS动画小结" class="headerlink" title="iOS动画小结"></a>iOS动画小结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="UIView，CALayer的关系及区别"><a href="#UIView，CALayer的关系及区别" class="headerlink" title="UIView，CALayer的关系及区别"></a>UIView，CALayer的关系及区别</h3><p>框架及继承</p>
<ul>
<li>CALayer 基于 QuartzCore 框架<br>   QuartzCore中常见的如：CAAnimation(核心动画架构)、CAEmitterLayer(粒子动画Emitter发射器)、      CAEmitterCell(粒子动画)、CATransform3D、CALayer等</li>
<li>UIView 基于 UIKit 框架</li>
<li>UIView是直接继承自UIResponder的</li>
<li>CALayer是直接继承自NSObject<br>结构及功能</li>
<li>view负责了用户的交互以及对layer的管理，layer则负责了所有能让用户看到的东西。</li>
<li>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有SubLayers，View 内部有SubViews.但是 Layer 比 View 多了个anchorPoint。<a href="https://www.cnblogs.com/jgl-blog/p/5735307.html">position与anchorPoint</a></li>
<li>在 View显示的时候，UIView做为Layer的CALayerDelegate,View 的显示内容取决于内部的 CALayer 的 display。</li>
<li>layer 内部维护着三个layer tree,分为 model layer tree(模型图层树) 、presentation layer tree（表示图层树） 、render layer tree（渲染图层树）,在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentationLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer。<br>这三种图层树有什么作用呢？说到有啥作用，就不得不提Core Animation 核心动画了。因为这三个图层在核心动画中才能显示出它们的特点和用处。下面是官方文档的说明：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模型图层树 中的对象是应用程序与之交互的对象。此树中的对象是存储任何动画的目标值的模型对象。每当更改图层的属性时，都使用其中一个对象。</span><br><span class="line">表示图层树 中的对象包含任何正在运行的动画的飞行中值。层树对象包含动画的目标值，而表示树中的对象反映屏幕上显示的当前值。您永远不应该修改此树中的对象。相反，您可以使用这些对象来读取当前动画值，也许是为了从这些值开始创建新动画。</span><br><span class="line">渲染图层树 中的对象执行实际动画，并且是Core Animation的私有动画。</span><br></pre></td></tr></table></figure>
<a href="https://imgchr.com/i/r8sob6"><img src="https://s3.ax1x.com/2020/12/17/r8sob6.png" alt="r8sob6.png"></a><br>详细内容参考文章：<a href="https://www.jianshu.com/p/d09e7929f269">iOS 详解 CALayer 中的”模型层”和”展示层”</a></li>
</ul>
<h2 id="动画详细介绍"><a href="#动画详细介绍" class="headerlink" title="动画详细介绍"></a>动画详细介绍</h2><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><p>iOS动画主要是指Core Animation框架。官方使用文档地址为：Core Animation Guide。<br>Core Animation是iOS和macOS平台上负责图形渲染与动画的基础框架。Core Animation可以作用与动画视图或者其他可视元素，为你完成了动画所需的大部分绘帧工作。你只需要配置少量的动画参数（如开始点的位置和结束点的位置）即可使用Core Animation的动画效果。Core Animation将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。这种自动化的图形加速技术让动画拥有更高的帧率并且显示效果更加平滑，不会加重CPU的负担而影响程序的运行速度。<br>总的来说，从涉及类的形式来看，iOS动画有：基于UIView的仿射形变动画，基于CAAnimation及其子类的动画，基于CG的动画，暂时先总结前两种动画。</p>
<h4 id="二、动画类型介绍"><a href="#二、动画类型介绍" class="headerlink" title="二、动画类型介绍"></a>二、动画类型介绍</h4><h5 id="1、UIView动画"><a href="#1、UIView动画" class="headerlink" title="1、UIView动画"></a>1、UIView动画</h5><p>UIView动画实质上是对Core Animation的封装，提供简洁的动画接口。<br>UIView动画可以设置的动画属性有:</p>
<ul>
<li>大小变化(frame)</li>
<li>拉伸变化(bounds)</li>
<li>中心位置(center)</li>
<li>旋转(transform)</li>
<li>透明度(alpha)</li>
<li>背景颜色(backgroundColor)</li>
<li>拉伸内容(contentStretch)</li>
</ul>
<p>UIview 类方法动画 （iOS13.0后废弃，需要用block动画代替）</p>
<h6 id="1）动画的开始和结束方法"><a href="#1）动画的开始和结束方法" class="headerlink" title="1）动画的开始和结束方法"></a>1）动画的开始和结束方法</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UIView beginAnimations:(nullable NSString *) context:(nullable void *)];</span><br></pre></td></tr></table></figure>
<p>第一个参数：动画标识<br>第二个参数：附加参数，在设置了代理的情况下，此参数将发送到setAnimationWillStartSelector和setAnimationDidStopSelector所指定的方法。大部分情况下，我们设置为nil即可。<br>1.2 结束动画标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UIView commitAnimations];</span><br></pre></td></tr></table></figure>
<h6 id="2）动画参数的设置方法"><a href="#2）动画参数的设置方法" class="headerlink" title="2）动画参数的设置方法"></a>2）动画参数的设置方法</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//动画持续时间</span><br><span class="line">[UIView setAnimationDuration:(NSTimeInterval)];</span><br><span class="line">//动画的代理对象</span><br><span class="line">[UIView setAnimationDelegate:(nullable id)];</span><br><span class="line">//设置动画将开始时代理对象执行的SEL</span><br><span class="line">[UIView setAnimationWillStartSelector:(nullable SEL)];</span><br><span class="line">//设置动画结束时代理对象执行的SEL</span><br><span class="line">[UIView setAnimationDidStopSelector:(nullable SEL)];</span><br><span class="line">//设置动画延迟执行的时间</span><br><span class="line">[UIView setAnimationDelay:(NSTimeInterval)];</span><br><span class="line">//设置动画的重复次数</span><br><span class="line">[UIView setAnimationRepeatCount:(float)];</span><br><span class="line">//设置动画的曲线</span><br><span class="line">[UIView setAnimationCurve:(UIViewAnimationCurve)];</span><br><span class="line">UIViewAnimationCurve的枚举值如下：</span><br><span class="line">UIViewAnimationCurveEaseInOut,         // 慢进慢出（默认值）</span><br><span class="line">UIViewAnimationCurveEaseIn,            // 慢进</span><br><span class="line">UIViewAnimationCurveEaseOut,           // 慢出</span><br><span class="line">UIViewAnimationCurveLinear             // 匀速</span><br><span class="line">//设置是否从当前状态开始播放动画</span><br><span class="line">[UIView setAnimationBeginsFromCurrentState:YES];</span><br><span class="line">假设上一个动画正在播放，且尚未播放完毕，我们将要进行一个新的动画：</span><br><span class="line">当为YES时：动画将从上一个动画所在的状态开始播放</span><br><span class="line">当为NO时：动画将从上一个动画所指定的最终状态开始播放（此时上一个动画马上结束）</span><br><span class="line">//设置动画是否继续执行相反的动画</span><br><span class="line">[UIView setAnimationRepeatAutoreverses:(BOOL)];</span><br><span class="line">//是否禁用动画效果（对象属性依然会被改变，只是没有动画效果）</span><br><span class="line">[UIView setAnimationsEnabled:(BOOL)];</span><br><span class="line">//设置视图的过渡效果</span><br><span class="line">[UIView setAnimationTransition:(UIViewAnimationTransition) forView:(nonnull      UIView *) cache:(BOOL)];</span><br><span class="line"> 第一个参数：UIViewAnimationTransition的枚举值如下</span><br><span class="line">     UIViewAnimationTransitionNone,              //不使用动画</span><br><span class="line">     UIViewAnimationTransitionFlipFromLeft,      //从左向右旋转翻页</span><br><span class="line">     UIViewAnimationTransitionFlipFromRight,     //从右向左旋转翻页</span><br><span class="line">     UIViewAnimationTransitionCurlUp,            //从下往上卷曲翻页</span><br><span class="line">     UIViewAnimationTransitionCurlDown,          //从上往下卷曲翻页</span><br><span class="line"> 第二个参数：需要过渡效果的View</span><br><span class="line"> 第三个参数：是否使用视图缓存，YES：视图在开始和结束时渲染一次；NO：视图在每一帧都渲染</span><br></pre></td></tr></table></figure>
<h5 id="2、UIview-Block动画"><a href="#2、UIview-Block动画" class="headerlink" title="2、UIview Block动画"></a>2、UIview Block动画</h5><p>iOS4.0以后，增加了Block动画块，提供更简洁的方式来实现动画。<br>Block动画方法</p>
<h5 id="1）Block动画方法"><a href="#1）Block动画方法" class="headerlink" title="1）Block动画方法"></a>1）Block动画方法</h5><h6 id="1、最简洁的Block动画：包含时间和动"><a href="#1、最简洁的Block动画：包含时间和动" class="headerlink" title="1、最简洁的Block动画：包含时间和动"></a>1、最简洁的Block动画：包含时间和动</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UIView animateWithDuration:(NSTimeInterval)  //动画持续时间</span><br><span class="line">                 animations:^&#123;</span><br><span class="line">                 //执行的动画</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h6 id="2、带有动画完成回调的Block动画"><a href="#2、带有动画完成回调的Block动画" class="headerlink" title="2、带有动画完成回调的Block动画"></a>2、带有动画完成回调的Block动画</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UIView animateWithDuration:(NSTimeInterval)  //动画持续时间</span><br><span class="line">                 animations:^&#123;</span><br><span class="line">               //执行的动画</span><br><span class="line">&#125;                completion:^(BOOL finished) &#123;</span><br><span class="line">               //动画执行完毕后的操作</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h6 id="3、可设置延迟时间和过渡效果的Block动画"><a href="#3、可设置延迟时间和过渡效果的Block动画" class="headerlink" title="3、可设置延迟时间和过渡效果的Block动画"></a>3、可设置延迟时间和过渡效果的Block动画</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UIView animateWithDuration:(NSTimeInterval) //动画持续时间</span><br><span class="line">                      delay:(NSTimeInterval) //动画延迟执行的时间</span><br><span class="line">                    options:(UIViewAnimationOptions) //动画的过渡效果</span><br><span class="line">                 animations:^&#123;</span><br><span class="line">                  //执行的动画</span><br><span class="line">&#125;                completion:^(BOOL finished) &#123;</span><br><span class="line">                  //动画执行完毕后的操作</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>UIViewAnimationOptions的枚举值如下，可组合使用：</p>
<figure class="highlight plaintext"><figcaption><span> </span><a href="//进行动画时布局子控件">link</a></figcaption><table><tr><td class="code"><pre><span class="line">UIViewAnimationOptionAllowUserInteraction      //进行动画时允许用户交互</span><br><span class="line">UIViewAnimationOptionBeginFromCurrentState     //从当前状态开始动画</span><br><span class="line">UIViewAnimationOptionRepeat                    //无限重复执行动画</span><br><span class="line">UIViewAnimationOptionAutoreverse               //执行动画回路</span><br><span class="line">UIViewAnimationOptionOverrideInheritedDuration //忽略嵌套动画的执行时间设置</span><br><span class="line">UIViewAnimationOptionOverrideInheritedCurve    //忽略嵌套动画的曲线设置</span><br><span class="line">UIViewAnimationOptionAllowAnimatedContent      //转场：进行动画时重绘视图</span><br><span class="line">UIViewAnimationOptionShowHideTransitionViews   //转场：移除（添加和移除图层的）动画效果</span><br><span class="line">UIViewAnimationOptionOverrideInheritedOptions  //不继承父动画设置</span><br><span class="line"></span><br><span class="line">UIViewAnimationOptionCurveEaseInOut            //时间曲线，慢进慢出（默认值）</span><br><span class="line">UIViewAnimationOptionCurveEaseIn               //时间曲线，慢进</span><br><span class="line">UIViewAnimationOptionCurveEaseOut              //时间曲线，慢出</span><br><span class="line">UIViewAnimationOptionCurveLinear               //时间曲线，匀速</span><br><span class="line"></span><br><span class="line">UIViewAnimationOptionTransitionNone            //转场，不使用动画</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromLeft    //转场，从左向右旋转翻页</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromRight   //转场，从右向左旋转翻页</span><br><span class="line">UIViewAnimationOptionTransitionCurlUp          //转场，下往上卷曲翻页</span><br><span class="line">UIViewAnimationOptionTransitionCurlDown        //转场，从上往下卷曲翻页</span><br><span class="line">UIViewAnimationOptionTransitionCrossDissolve   //转场，交叉消失和出现</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromTop     //转场，从上向下旋转翻页</span><br><span class="line">UIViewAnimationOptionTransitionFlipFromBottom  //转场，从下向上旋转翻页</span><br></pre></td></tr></table></figure>
<h6 id="4、Spring动画"><a href="#4、Spring动画" class="headerlink" title="4、Spring动画"></a>4、Spring动画</h6><p>iOS7.0后新增Spring动画（iOS系统动画大部分采用Spring Animation，适用于所有可被添加动画效果的属性）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UIView animateWithDuration:(NSTimeInterval)//动画持续时间</span><br><span class="line">                      delay:(NSTimeInterval)//动画延迟执行的时间</span><br><span class="line">     usingSpringWithDamping:(CGFloat)//震动效果，范围0~1，数值越小震动效果越明显</span><br><span class="line">      initialSpringVelocity:(CGFloat)//初始速度，数值越大初始速度越快</span><br><span class="line">                    options:(UIViewAnimationOptions)//动画的过渡效果</span><br><span class="line">                 animations:^&#123;</span><br><span class="line">                    //执行的动画</span><br><span class="line">&#125;</span><br><span class="line">                 completion:^(BOOL finished) &#123;</span><br><span class="line">                    //动画执行完毕后的操作</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>5、Keyframes动画</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UIView animateKeyframesWithDuration:(NSTimeInterval)//动画持续时间</span><br><span class="line">                               delay:(NSTimeInterval)//动画延迟执行的时间</span><br><span class="line">                             options:(UIViewKeyframeAnimationOptions)//动画的过渡效果</span><br><span class="line">                          animations:^&#123;</span><br><span class="line">                        //执行的关键帧动画</span><br><span class="line">&#125;</span><br><span class="line">                          completion:^(BOOL finished) &#123;</span><br><span class="line">                        //动画执行完毕后的操作</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>UIViewKeyframeAnimationOptions的枚举值如下，可组合使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIViewAnimationOptionLayoutSubviews           //进行动画时布局子控件</span><br><span class="line">UIViewAnimationOptionAllowUserInteraction     //进行动画时允许用户交互</span><br><span class="line">UIViewAnimationOptionBeginFromCurrentState    //从当前状态开始动画</span><br><span class="line">UIViewAnimationOptionRepeat                   //无限重复执行动画</span><br><span class="line">UIViewAnimationOptionAutoreverse              //执行动画回路</span><br><span class="line">UIViewAnimationOptionOverrideInheritedDuration //忽略嵌套动画的执行时间设置</span><br><span class="line">UIViewAnimationOptionOverrideInheritedOptions //不继承父动画设置</span><br><span class="line"></span><br><span class="line">UIViewKeyframeAnimationOptionCalculationModeLinear     //运算模式 :连续</span><br><span class="line">UIViewKeyframeAnimationOptionCalculationModeDiscrete   //运算模式 :离散</span><br><span class="line">UIViewKeyframeAnimationOptionCalculationModePaced      //运算模式 :均匀执行</span><br><span class="line">UIViewKeyframeAnimationOptionCalculationModeCubic      //运算模式 :平滑</span><br><span class="line">UIViewKeyframeAnimationOptionCalculationModeCubicPaced //运算模式 :平滑均匀</span><br></pre></td></tr></table></figure>
<p>各种运算模式的直观比较如下图：<br><a href="https://imgchr.com/i/r8gesA"><img src="https://s3.ax1x.com/2020/12/17/r8gesA.png" alt="r8gesA.png"></a></p>
<p>增加关键帧的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UIView addKeyframeWithRelativeStartTime:(double)//动画开始的时间（占总时间的比例）</span><br><span class="line">                        relativeDuration:(double) //动画持续时间（占总时间的比例）</span><br><span class="line">                              animations:^&#123;</span><br><span class="line">                            //执行的动画</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="6、转场动画"><a href="#6、转场动画" class="headerlink" title="6、转场动画"></a>6、转场动画</h4><h5 id="6-1-从旧视图转到新视图的动画效果"><a href="#6-1-从旧视图转到新视图的动画效果" class="headerlink" title="6.1 从旧视图转到新视图的动画效果"></a>6.1 从旧视图转到新视图的动画效果</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UIView transitionFromView:(nonnull UIView *)</span><br><span class="line">                    toView:(nonnull UIView *)</span><br><span class="line">                  duration:(NSTimeInterval)</span><br><span class="line">                   options:(UIViewAnimationOptions)</span><br><span class="line">                completion:^(BOOL finished) &#123;</span><br><span class="line">                    //动画执行完毕后的操作</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>在该动画过程中，fromView 会从父视图中移除，并将 toView 添加到父视图中，注意转场动画的作用对象是父视图（过渡效果体现在父视图上）。<br>调用该方法相当于执行下面两句代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[fromView.superview addSubview:toView];</span><br><span class="line">[fromView removeFromSuperview];</span><br></pre></td></tr></table></figure>
<h5 id="6-2-单个视图的过渡效果"><a href="#6-2-单个视图的过渡效果" class="headerlink" title="6.2 单个视图的过渡效果"></a>6.2 单个视图的过渡效果</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[UIView transitionWithView:(nonnull UIView *)</span><br><span class="line">                  duration:(NSTimeInterval)</span><br><span class="line">                   options:(UIViewAnimationOptions)</span><br><span class="line">                animations:^&#123;</span><br><span class="line">                //执行的动画</span><br><span class="line">&#125;</span><br><span class="line">                completion:^(BOOL finished) &#123;</span><br><span class="line">                //动画执行完毕后的操作</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="3、核心动画"><a href="#3、核心动画" class="headerlink" title="3、核心动画"></a>3、核心动画</h3><h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>Core Animation(核心动画)是一组功能强大、效果华丽的动画API，无论在iOS系统或者在开发App的过程中，都有大量应用。<br>核心动画所在的位置如下图所示：<br><a href="https://imgchr.com/i/r828k6"><img src="https://s3.ax1x.com/2020/12/17/r828k6.png" alt="r828k6.png"></a><br>可以看到，核心动画位于UIKit的下一层，相比UIView动画，它可以实现更复杂的动画效果。<br>核心动画作用在CALayer（Core animation layer）上，CALayer从概念上类似UIView，我们可以将UIView看成是一种特殊的CALayer（可以响应事件）。<br>实际上，每一个view都有其对应的layer，这个layer是root layer：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property(nonatomic,readonly,strong)                CALayer  *layer;</span><br></pre></td></tr></table></figure>

<p>给view加上动画，本质上是对其layer进行操作，layer包含了各种支持动画的属性，动画则包含了属性变化的值、变化的速度、变化的时间等等，两者结合产生动画的过程。<br>核心动画和UIView动画的对比：UIView动画可以看成是对核心动画的封装，和UIView动画不同的是，通过核心动画改变layer的状态（比如position），动画执行完毕后实际上是没有改变的（表面上看起来已改变）。</p>
<h5 id="2、核心动画优点："><a href="#2、核心动画优点：" class="headerlink" title="2、核心动画优点："></a>2、核心动画优点：</h5><p>1）性能强大，使用硬件加速，可以同时向多个图层添加不同的动画效果<br>2）接口易用，只需要少量的代码就可以实现复杂的动画效果。<br>3）运行在后台线程中，在动画过程中可以响应交互事件（UIView动画默认动画过程中不响应交互事件）。</p>
<h5 id="3、核心动画类的层次结构："><a href="#3、核心动画类的层次结构：" class="headerlink" title="3、核心动画类的层次结构："></a>3、核心动画类的层次结构：</h5><p><a href="https://imgchr.com/i/r82B7t"><img src="https://s3.ax1x.com/2020/12/17/r82B7t.png" alt="r82B7t.png"></a></p>
<p>CAAnimation是所有动画对象的父类，实现CAMediaTiming协议，负责控制动画的时间、速度和时间曲线等等，是一个抽象类，不能直接使用。<br>CAPropertyAnimation ：是CAAnimation的子类，它支持动画地显示图层的keyPath，一般不直接使用。<br>iOS9.0之后新增CASpringAnimation类，它实现弹簧效果的动画，是CABasicAnimation的子类。<br>核心动画类中可以直接使用的类有：<br>CABasicAnimation<br>CAKeyframeAnimation<br>CATransition<br>CAAnimationGroup<br>CASpringAnimation</p>
<h5 id="4、详细介绍"><a href="#4、详细介绍" class="headerlink" title="4、详细介绍"></a>4、详细介绍</h5><h6 id="1）CAAnimation"><a href="#1）CAAnimation" class="headerlink" title="1）CAAnimation"></a>1）CAAnimation</h6><p>CAAnimation是所有动画对象的父类，负责控制动画的持续时间和速度，是个抽象类，不能直接使用，应该使用它具体的子类<br>属性解读</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>duration</td>
<td>动画的持续时间</td>
</tr>
<tr>
<td>repeatCount</td>
<td>重复次数，无限循环可以设置HUGE_VALF或者MAXFLOAT</td>
</tr>
<tr>
<td>repeatDuration</td>
<td>重复时间</td>
</tr>
<tr>
<td>beginTime</td>
<td>可以用来设置动画延迟执行时间，若想延迟2s，就设置CACurrentMediaTime()+2，CACurrentMediaTime()为图层的 当前时间</td>
</tr>
<tr>
<td>autoreverses</td>
<td>动画自动逆向执行，默认为No</td>
</tr>
<tr>
<td>speed</td>
<td>动画执行速度</td>
</tr>
<tr>
<td>removedOnCompletion</td>
<td>动画的持续时间</td>
</tr>
<tr>
<td>duration</td>
<td>默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards</td>
</tr>
<tr>
<td>fillMode</td>
<td>决定当前对象在非active时间段的行为。比如动画开始之前或者动画结束之后</td>
</tr>
<tr>
<td>timingFunction</td>
<td>速度控制函数，控制动画运行的节奏，例：anima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn]</td>
</tr>
<tr>
<td>delegate</td>
<td>动画代理，监听动画的开始和结束</td>
</tr>
</tbody></table>
<ul>
<li><p>fillMode属性值（要想fillMode有效，最好设置removedOnCompletion = NO）<br>kCAFillModeRemoved这个是默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态<br>CAFillModeForwards 当动画结束后，layer会一直保持着动画最后的状态<br>kCAFillModeBackwards 在动画开始前，只需要将动画加入了一个layer，layer便立即进入动画的初始状态并等待动画开始。<br>kCAFillModeBoth这个其实就是上面两个的合成.动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态</p>
</li>
<li><p>速度控制函数(CAMediaTimingFunction)<br><code>kCAMediaTimingFunctionLinear（线性）</code>：匀速，给你一个相对静态的感觉<br><code>kCAMediaTimingFunctionEaseIn（渐进）</code>：动画缓慢进入，然后加速离开<br><code>kCAMediaTimingFunctionEaseOut（渐出）</code>：动画全速进入，然后减速的到达目的地<br><code>kCAMediaTimingFunctionEaseInEaseOut</code>（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。这个是默认的动画行为。 </p>
</li>
<li><p>delegate：动画代理<br>代理方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)animationDidStart:(CAAnimation *)anim;  //动画开始</span><br><span class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag; //动画结束</span><br></pre></td></tr></table></figure>
<h4 id="核心动画类的核心方法："><a href="#核心动画类的核心方法：" class="headerlink" title="核心动画类的核心方法："></a>核心动画类的核心方法：</h4><h5 id="1-初始化CAAnimation对象一般使用animation方法生成实例"><a href="#1-初始化CAAnimation对象一般使用animation方法生成实例" class="headerlink" title="1.初始化CAAnimation对象一般使用animation方法生成实例"></a>1.初始化CAAnimation对象一般使用animation方法生成实例</h5></li>
</ul>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> + (instancetype)animation;</span><br><span class="line">如果是CAPropertyAnimation的子类，还可以通过animationWithKeyPath生成实例</span><br><span class="line"> + (instancetype)animationWithKeyPath:(nullable NSString *)path;</span><br></pre></td></tr></table></figure>
<h5 id="2-设置动画的相关属性"><a href="#2-设置动画的相关属性" class="headerlink" title="2.设置动画的相关属性"></a>2.设置动画的相关属性</h5><p>设置动画的执行时间，执行曲线，keyPath的目标值，代理等等</p>
<h5 id="3-动画的添加和移除"><a href="#3-动画的添加和移除" class="headerlink" title="3.动画的添加和移除"></a>3.动画的添加和移除</h5><p>调用CALayer的addAnimation:forKey:方法将动画添加到CALayer中，这样动画就开始执行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> - (void)addAnimation:(CAAnimation *)anim forKey:(nullable NSString *)key;</span><br><span class="line">调用CALayer的removeAnimation方法停止CALayer中的动画</span><br><span class="line"> - (void)removeAnimationForKey:(NSString *)key;</span><br><span class="line"> - (void)removeAllAnimations;</span><br></pre></td></tr></table></figure>
<h5 id="４-核心动画类的常用属性"><a href="#４-核心动画类的常用属性" class="headerlink" title="４.核心动画类的常用属性"></a>４.核心动画类的常用属性</h5><p>keyPath：可以指定keyPath为CALayer的属性值，并对它的值进行修改，以达到对应的动画效果，需要注意的是部分属性值是不支持动画效果的。<br>以下是具有动画效果的keyPath：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//CATransform3D Key Paths : (example)transform.rotation.z</span><br><span class="line">//rotation.x</span><br><span class="line">//rotation.y</span><br><span class="line">//rotation.z</span><br><span class="line">//rotation 旋轉</span><br><span class="line">//scale.x</span><br><span class="line">//scale.y</span><br><span class="line">//scale.z</span><br><span class="line">//scale 缩放</span><br><span class="line">//translation.x</span><br><span class="line">//translation.y</span><br><span class="line">//translation.z</span><br><span class="line">//translation 平移</span><br><span class="line"></span><br><span class="line">//CGPoint Key Paths : (example)position.x</span><br><span class="line">//x</span><br><span class="line">//y</span><br><span class="line"></span><br><span class="line">//CGRect Key Paths : (example)bounds.size.width</span><br><span class="line">//origin.x</span><br><span class="line">//origin.y</span><br><span class="line">//origin</span><br><span class="line">//size.width</span><br><span class="line">//size.height</span><br><span class="line">//size</span><br><span class="line"></span><br><span class="line">//opacity</span><br><span class="line">//backgroundColor</span><br><span class="line">//cornerRadius </span><br><span class="line">//borderWidth</span><br><span class="line">//contents </span><br><span class="line"></span><br><span class="line">//Shadow Key Path:</span><br><span class="line">//shadowColor </span><br><span class="line">//shadowOffset </span><br><span class="line">//shadowOpacity </span><br><span class="line">//shadowRadius </span><br></pre></td></tr></table></figure>
<h5 id="2-CAPropertyAnimation"><a href="#2-CAPropertyAnimation" class="headerlink" title="2)   CAPropertyAnimation"></a>2)   CAPropertyAnimation</h5><p>CAPropertyAnimation也是一个抽象类，自身并不能对layer进行动画操作，需要其子类<br>CABasicAnimation和CAKeyframeAnimation来实现动画操作。<br>属性解读：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>keyPath</td>
<td>指定接收层动画的动画类型</td>
</tr>
<tr>
<td>cumulative</td>
<td>下一次动画执行是否接着刚才的动画，默认为false</td>
</tr>
<tr>
<td>additive</td>
<td>如何处理多个动画在同一时间段执行的结果，若为true，同一时间段的动画合成为一个动画，默认为false。（使用 CAKeyframeAnimation 时必须将该属性指定为 true ，否则不会出现期待的结果）</td>
</tr>
</tbody></table>
<h5 id="3）CABasicAnimation-——-基本动画"><a href="#3）CABasicAnimation-——-基本动画" class="headerlink" title="3）CABasicAnimation —— 基本动画"></a>3）CABasicAnimation —— 基本动画</h5><p>基本动画，是CAPropertyAnimation的子类</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>fromValue</td>
<td>NSValue类型，keyPath相应属性的初始值</td>
</tr>
<tr>
<td>toValue</td>
<td>NSValue类型， keyPath相应属性的结束值</td>
</tr>
</tbody></table>
<p>CABasicAnimation可以设定keyPath的起点，终点的值，动画会沿着设定点进行移动，CABasicAnimation可以看成是只有两个关键点的特殊的CAKeyFrameAnimation。<br>动画过程说明：<br>随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue<br>keyPath内容是CALayer的可动画Animatable属性<br>如果fillMode==kCAFillModeForwards同时removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</p>
<h5 id="4）CAKeyframeAnimation-——-关键帧动画"><a href="#4）CAKeyframeAnimation-——-关键帧动画" class="headerlink" title="4）CAKeyframeAnimation —— 关键帧动画"></a>4）CAKeyframeAnimation —— 关键帧动画</h5><p>关键帧动画，也是CAPropertyAnimation的子类，与CABasicAnimation的区别是：<br><code>CABasicAnimation</code>:只能从一个数值（fromValue）变到另一个数值（toValue）<br><code>CAKeyframeAnimation</code>:会使用一个NSArray保存这些数值。<br>可以设定keyPath起点、中间关键点（不止一个）、终点的值，每一帧所对应的时间，动画会沿着设定点进行移动。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>values</td>
<td>NSArray类型，里面的元素（NSValue）称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧</td>
</tr>
<tr>
<td>path</td>
<td>可以设置一个CGPathRef、CGMutablePathRef，让图层按照路径轨迹移动。path只对CALayer的anchorPoint和position起作用。如果设置了path，那么values将被忽略</td>
</tr>
<tr>
<td>keyTimes</td>
<td>NSArray类型，可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的</td>
</tr>
</tbody></table>
<h5 id="5）CAAnimationGroup-——-动画组"><a href="#5）CAAnimationGroup-——-动画组" class="headerlink" title="5）CAAnimationGroup —— 动画组"></a>5）CAAnimationGroup —— 动画组</h5><p>动画组，是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入layer层后，组中所有动画对象可以同时并发运行</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>animations</td>
<td>用来保存一组动画对象的NSArray。默认情况下，一组动画对象是同时运行的，也可以通过设置各个动画对象的beginTime属性来更改动画的开始时间</td>
</tr>
</tbody></table>
<h5 id="6）CASpringAnimation-——-弹性动画"><a href="#6）CASpringAnimation-——-弹性动画" class="headerlink" title="6）CASpringAnimation —— 弹性动画"></a>6）CASpringAnimation —— 弹性动画</h5><p>CASpringAnimation是iOS9.0新加入动画类型，是CABasicAnimation的子类，用于实现弹簧动画。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mass</td>
<td>质量（影响弹簧的惯性，质量越大，弹簧惯性越大，运动的幅度越大）</td>
</tr>
<tr>
<td>stiffness</td>
<td>弹性系数（弹性系数越大，弹簧的运动越快）</td>
</tr>
<tr>
<td>damping</td>
<td>阻尼系数（阻尼系数越大，弹簧的停止越快）</td>
</tr>
<tr>
<td>initialVelocity</td>
<td>初始速率（弹簧动画的初始速度大小，弹簧运动的初始方向与初始速率的正负一致，若初始速率为0，表示忽略该属性）</td>
</tr>
<tr>
<td>settlingDuration</td>
<td>结算时间（根据动画参数估算弹簧开始运动到停止的时间，动画设置的时间最好根据此时间来设置）</td>
</tr>
</tbody></table>
<p>CASpringAnimation和UIView的SpringAnimation对比：</p>
<ol>
<li>CASpringAnimation 可以设置更多影响弹簧动画效果的属性，可以实现更复杂的弹簧动画效果，且可以和其他动画组合。</li>
<li>UIView的SpringAnimation实际上就是通过CASpringAnimation来实现。</li>
</ol>
<h5 id="7）CATransition"><a href="#7）CATransition" class="headerlink" title="7）CATransition"></a>7）CATransition</h5><p>最后讲一下事务，在核心动画里面存在事务（CATransaction）这样一个概念，它负责协调多个动画原子更新显示操作。<br>简单来说事务是核心动画里面的一个基本的单元，动画的产生必然伴随着layer的Animatable属性的变化，而layer属性的变化必须属于某一个事务。<br>因此，核心动画依赖事务。</p>
<ul>
<li>事务的作用：保证一个或多个layer的一个或多个属性变化同时进行</li>
<li>事务分为隐式和显式：</li>
</ul>
<p>1.隐式：没有明显调用事务的方法，由系统自动生成事务。比如直接设置一个layer的position属性，则会在当前线程自动生成一个事务，并在下一个runLoop中自动commit事务。<br>2.显式：明显调用事务的方法（[CATransaction begin]和[CATransaction commit]）</p>
<p>CA事务的可设置属性（会覆盖隐式动画的设置）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animationDuration：动画时间</span><br><span class="line">animationTimingFunction：动画时间曲线</span><br><span class="line">disableActions：是否关闭动画</span><br><span class="line">completionBlock：动画执行完毕的回调</span><br></pre></td></tr></table></figure>

<p>事务支持嵌套使用：当最外层的事务commit后动画才会开始。</p>
<p>注意：只有非root layer才有隐式动画，根layer（rootLayer）类似于UIView中的一个layer层，非RootLayer层就是自己创建的layer层。<br>可以设置隐式动画关闭。当在设置隐式动画的动画效果时候，需要在提交的commit方法前面实现，否则，没有动画效果。如上面例子中的，在设置layer的position属性时候，没有提交上去，因此，效果图中的layer有一个瞬移的效果。</p>
<p>注意：如果父视图中的两个子视图互相切换，转场动画应加给父视图！</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>动画过渡类型</td>
</tr>
<tr>
<td>subtype</td>
<td>动画过渡方向</td>
</tr>
<tr>
<td>startProgress</td>
<td>动画起点(在整体动画的百分比)</td>
</tr>
<tr>
<td>endProgress</td>
<td>动画终点(在整体动画的百分比)</td>
</tr>
</tbody></table>
<p>动画过渡类型:<br>type的enum值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">kCATransitionFade 渐变</span><br><span class="line">kCATransitionMoveIn 覆盖</span><br><span class="line">kCATransitionPush 推出</span><br><span class="line">kCATransitionReveal 揭开</span><br></pre></td></tr></table></figure>

<p>动画过渡方向<br>subtype的enum值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kCATransitionFromRight 从右边</span><br><span class="line">kCATransitionFromLeft 从左边</span><br><span class="line">kCATransitionFromTop 从顶部</span><br><span class="line">kCATransitionFromBottom 从底部</span><br></pre></td></tr></table></figure>



<p>还有一些私有动画类型，效果很炫酷，不过不推荐使用。私有动画类型的值有：”cube”、”suckEffect”、”oglFlip”、 “rippleEffect”、”pageCurl”、”pageUnCurl”等等。</p>
<h4 id="Written-By-多点-移动运营研发部-李涛"><a href="#Written-By-多点-移动运营研发部-李涛" class="headerlink" title="Written By 多点-移动运营研发部-李涛"></a>Written By 多点-移动运营研发部-李涛</h4>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>动画相关</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS离屏渲染是怎么回事?</title>
    <url>/2021/05/19/iOS%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="什么是离屏渲染？"><a href="#什么是离屏渲染？" class="headerlink" title="什么是离屏渲染？"></a>什么是离屏渲染？</h1><p>在几乎所有的面试过程中，我们都会被问到一个问题，什么是离屏渲染？为什么我们会被问到这个问题呢？看起来这个问题跟我们的开发并没有任何的关联。</p>
<h2 id="1-了解CPU和GPU的区别"><a href="#1-了解CPU和GPU的区别" class="headerlink" title="1.了解CPU和GPU的区别"></a>1.了解CPU和GPU的区别</h2><p><strong>CPU</strong>（Central Processing Unit）:现代计算机整个系统的运算核心、控制核心。<br><strong>GPU</strong>（Graphics Processing Unit）:可进行绘图运算工作的专用微型处理器，是连接计算机和显示器终端的纽带。<br><img src="https://s3.ax1x.com/2021/02/08/yUksQe.png" alt="CPU和GPU"></p>
<p>CPU需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。这些都使得CPU的内部结构异常复杂。<br>而GPU面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境。</p>
<p><strong>CPU/GPU的内部组成</strong><br><a href="https://imgchr.com/i/yUk7Lj"><img src="https://s3.ax1x.com/2021/02/08/yUk7Lj.png" alt="CPU和GPU的内部组成"></a><br>图片来自nVidia CUDA文档。其中绿色的是计算单元，橙红色的是存储单元，橙黄色的是控制单元。</p>
<p>苹果在各种文档中常常提到的硬件加速器实际上就是GPU。<br>在苹果的系统中，GPU主要负责：<br>1.手机和mac的渲染问题；<br>2.因为其卓越的运算能力，通常还用来处理音视频的编解码/视频滤镜/特效处理/人工智能机器学习计算。</p>
<h2 id="2-显示器成像的原理（几代显示器的变迁）"><a href="#2-显示器成像的原理（几代显示器的变迁）" class="headerlink" title="2.显示器成像的原理（几代显示器的变迁）"></a>2.显示器成像的原理（几代显示器的变迁）</h2><h3 id="2-1-随机扫描显示"><a href="#2-1-随机扫描显示" class="headerlink" title="2.1 随机扫描显示"></a>2.1 随机扫描显示</h3><p><a href="https://imgchr.com/i/yU8Azj"><img src="https://s3.ax1x.com/2021/02/08/yU8Azj.png" alt="随机扫描显示"></a></p>
<p>采用随机定位的方式控制电子束的移动，一般会带有图形数据输入设备（例如光笔、作图板、跟踪球等），人机交互性好，与计算机对接方便。<br>优点：电子束随机定位、线条质量好、缓存容量少、人机交互方便；<br>缺点：不能显示太复杂的画面，而且亮度等级和颜色种类较少。</p>
<h3 id="2-2-光栅扫描显示系统组成"><a href="#2-2-光栅扫描显示系统组成" class="headerlink" title="2.2 光栅扫描显示系统组成"></a>2.2 光栅扫描显示系统组成</h3><p><a href="https://imgchr.com/i/yU8uwV"><img src="https://s3.ax1x.com/2021/02/08/yU8uwV.png" alt="屏幕扫描"></a></p>
<p>光栅扫描显示：电子束通过偏转不断的从左到右从上到下将图片逐行逐点的扫描到显示屏上，通过控制电子束的强弱来控制黑白灰度等级或彩色的图像。整个显示屏面扫描线为2^n行，每一行又分为2^m个点。这样整个显示屏面就分为了2^n * 2^m个小方块，每个方块就是我们说的一个像素。</p>
<p><a href="https://imgchr.com/i/yU8lYF"><img src="https://s3.ax1x.com/2021/02/08/yU8lYF.png" alt="yU8lYF.png"></a><br>  帧缓存存储器(左)    显示器(右)</p>
<p>我们当前使用的显示器都是彩色的，以彩色的为例，在不经过特殊处理的情况下，我们要显示一个图形，系统会自动生成一个跟屏幕像素一致的帧缓冲区，一个像素点通过红、黄、蓝、透明度4个通道来判定当前的颜色，每个通道占8位，所以帧缓冲区的大小可以等于屏幕像素* 4*8。所以我们显示的任何一个图形，都会先绘制到帧缓冲区然后通过视频控制器绘制到屏幕上。</p>
<p><a href="https://imgchr.com/i/yU80YD"><img src="https://s3.ax1x.com/2021/02/08/yU80YD.png" alt="高级光栅扫描显示"></a></p>
<p>CPU处理好图片生成纹理，通过系统总线将数据传输到GPU处理,处理完毕后放到帧缓冲区,然后通过显示器控制器绘制到显示器屏幕上。</p>
<h2 id="3-屏幕成像和卡顿问题"><a href="#3-屏幕成像和卡顿问题" class="headerlink" title="3.屏幕成像和卡顿问题"></a>3.屏幕成像和卡顿问题</h2><h3 id="3-1屏幕撕裂"><a href="#3-1屏幕撕裂" class="headerlink" title="3.1屏幕撕裂"></a>3.1屏幕撕裂</h3><p><a href="https://imgchr.com/i/yU86OI"><img src="https://s3.ax1x.com/2021/02/08/yU86OI.png" alt="屏幕撕裂1"></a></p>
<p><a href="https://imgchr.com/i/yU8gmt"><img src="https://s3.ax1x.com/2021/02/08/yU8gmt.png" alt="屏幕撕裂2"></a><br>在屏幕扫描的过程中是逐行扫描。最理想的结果是，每一次的扫描，在CPU和GPU协作完成之后，得到结果，然后通过显示控制器显示到显示器上。GPU在显示一个比较复杂的图层的时候，需要消耗时间，例如扫描展示上图的时候，在逐行扫描绘制的到一半的时候，帧缓冲区的内容产生了更新，这时就会出现上半部分是上一帧的数据，下半部分是下一帧的数据，出现屏幕撕裂的现象。<br><a href="https://imgchr.com/i/yU8RTf"><img src="https://s3.ax1x.com/2021/02/08/yU8RTf.png" alt="缓存区展示"></a></p>
<h3 id="3-2-垂直同步-双缓存区"><a href="#3-2-垂直同步-双缓存区" class="headerlink" title="3.2 垂直同步+双缓存区"></a>3.2 垂直同步+双缓存区</h3><h4 id="双缓存区"><a href="#双缓存区" class="headerlink" title="双缓存区"></a>双缓存区</h4><p>用两个帧缓冲区来存储数据，来互相交叠的显示图像<br><a href="https://imgchr.com/i/yU87Xn"><img src="https://s3.ax1x.com/2021/02/08/yU87Xn.png" alt="双缓存区"></a></p>
<h4 id="垂直同步"><a href="#垂直同步" class="headerlink" title="垂直同步"></a>垂直同步</h4><p>当一个帧缓冲区的数据完成一次完整的屏幕绘制后，会发送一个信号告知此次绘制完成，让GPU切换缓冲区，开始进行下一次绘制，这个信号就是我们说的垂直同步信号。就是上面屏幕扫描示意图上的那根黄色的线。</p>
<h3 id="3-3-掉帧Jank"><a href="#3-3-掉帧Jank" class="headerlink" title="3.3 掉帧Jank"></a>3.3 掉帧Jank</h3><p><a href="https://imgchr.com/i/yU8L7V"><img src="https://s3.ax1x.com/2021/02/08/yU8L7V.png" alt="掉帧Jank"></a><br>当前屏幕在显示A帧的时候，显示完毕后刷新时发现B帧没有准备好，无法显示B帧，只能继续显示A帧，这个过程叫做掉帧。</p>
<h3 id="3-4-三缓存区解决掉帧"><a href="#3-4-三缓存区解决掉帧" class="headerlink" title="3.4 三缓存区解决掉帧"></a>3.4 三缓存区解决掉帧</h3><p>为了减少掉帧，可以使用A,B,C 3个缓冲区来处理掉帧。<br>苹果是使用双缓冲区、</p>
<h3 id="3-5-屏幕卡顿的本质（掉帧的本质）"><a href="#3-5-屏幕卡顿的本质（掉帧的本质）" class="headerlink" title="3.5 屏幕卡顿的本质（掉帧的本质）"></a>3.5 屏幕卡顿的本质（掉帧的本质）</h3><ul>
<li>CPU和GPU的计算时间过长，导致时间超过了一帧显示时间，在发送垂直同步刷新信号时，没有准备好下一帧的数据，导致掉帧了；（不要把图层数设置的过于复杂）</li>
<li>双缓存区只是减少屏幕撕裂问题，并不解决掉帧问题。<h2 id="4-渲染流程（屏幕的渲染本质）"><a href="#4-渲染流程（屏幕的渲染本质）" class="headerlink" title="4.渲染流程（屏幕的渲染本质）"></a>4.渲染流程（屏幕的渲染本质）</h2></li>
</ul>
<p><a href="https://imgchr.com/i/yUG9XR"><img src="https://s3.ax1x.com/2021/02/08/yUG9XR.png" alt="渲染本质"></a><br>一个图形的显示是有CPU和GPU协同完成的，CPU负责Application，图形处理、像素化、光栅化都是由GPU来处理。</p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>得到图源和纹理，例如图片的编解码等，由CPU来进行完成。</p>
<h3 id="Geometry-Processing（图形处理（OpenGL-Metal））"><a href="#Geometry-Processing（图形处理（OpenGL-Metal））" class="headerlink" title="Geometry Processing（图形处理（OpenGL/Metal））"></a>Geometry Processing（图形处理（OpenGL/Metal））</h3><p><strong>顶点着色器</strong>：在这里确定图形具体在硬件显示的位置，将坐标转换成屏幕上的坐标<br><strong>片元着色器</strong>：计算每一个像素点的颜色值</p>
<h3 id="Rasterization（光栅化）"><a href="#Rasterization（光栅化）" class="headerlink" title="Rasterization（光栅化）"></a>Rasterization（光栅化）</h3><p>将图形的每个像素的颜色计算出来以后，放入帧缓冲区中。<br>Piexl Processing (像素处理)<br>将帧缓冲区中的数据，绘制到屏幕上</p>
<h2 id="5-CoreAnimation渲染流水线"><a href="#5-CoreAnimation渲染流水线" class="headerlink" title="5.CoreAnimation渲染流水线"></a>5.CoreAnimation渲染流水线</h2><p><a href="https://imgchr.com/i/yUGF76"><img src="https://s3.ax1x.com/2021/02/08/yUGF76.png" alt="渲染流水线"></a><br>在Application中处理事件，处理完毕后提交刚刚的动作，然后在CoreAnimation中解码，解码完毕后将结果放到RunLoop中，在下一次 RunLoop执行到之后，GPU开始进行绘制渲染，渲染完毕后，开始显示。</p>
<h1 id="离屏渲染是怎么触发的"><a href="#离屏渲染是怎么触发的" class="headerlink" title="离屏渲染是怎么触发的?"></a>离屏渲染是怎么触发的?</h1><h2 id="1-怎么检测离屏渲染"><a href="#1-怎么检测离屏渲染" class="headerlink" title="1.怎么检测离屏渲染"></a>1.怎么检测离屏渲染</h2><p>通过系统的模拟器，可以直接检测离屏渲染<br><a href="https://imgchr.com/i/yUG7CD"><img src="https://s3.ax1x.com/2021/02/08/yUG7CD.png" alt="检测离屏渲染"></a><br>iOS 9.0以后，苹果对做了优化，对单个图层设置圆角，不会触发离屏渲染</p>
<h2 id="2-触发离屏渲染的两个原因"><a href="#2-触发离屏渲染的两个原因" class="headerlink" title="2.触发离屏渲染的两个原因"></a>2.触发离屏渲染的两个原因</h2><h3 id="2-1-苹果在显示一些复杂的需求的时候，没有办法一次性完成图层的动作，必须要分步骤完成，因此会产生离屏渲染。"><a href="#2-1-苹果在显示一些复杂的需求的时候，没有办法一次性完成图层的动作，必须要分步骤完成，因此会产生离屏渲染。" class="headerlink" title="2.1 苹果在显示一些复杂的需求的时候，没有办法一次性完成图层的动作，必须要分步骤完成，因此会产生离屏渲染。"></a>2.1 苹果在显示一些复杂的需求的时候，没有办法一次性完成图层的动作，必须要分步骤完成，因此会产生离屏渲染。</h3><p><a href="https://imgchr.com/i/yUJArn"><img src="https://s3.ax1x.com/2021/02/08/yUJArn.png" alt="遮罩产生离屏渲染的过程"></a></p>
<p>离屏渲染需要开辟额外的存储空间，同时离屏渲染的合成</p>
<h3 id="2-2-主动打开了光栅化（shouldRaserize）"><a href="#2-2-主动打开了光栅化（shouldRaserize）" class="headerlink" title="2.2 主动打开了光栅化（shouldRaserize）"></a>2.2 主动打开了光栅化（shouldRaserize）</h3><p>开启光栅化后，会触发离屏渲染，GPU 会强制把图层的渲染结果保存下来，方便下次复用。<br>当我们确定必须是使用离屏渲染的时候，可以主动开启光栅化，让离屏渲染缓冲区做复用，来减少性能消耗，例如毛玻璃效果。<br>shouldRasterize 光栅化使用建议：</p>
<ul>
<li>如果layer不能被复用，则没有必要打开光栅化；</li>
<li>如果layer不是静态的，需要被频繁修改，比如处于动画之中，那么开启离屏渲染反而影响效率；</li>
<li>离屏渲染缓存内容有时间限制，缓存内容100ms内没有被使用，则会被丢弃；</li>
<li>离屏渲染空间有限，超过2.5倍屏幕像素大小的话，也会失效，且无法复用。 </li>
</ul>
<h3 id="3-关于圆角在离屏渲染上的原理探索"><a href="#3-关于圆角在离屏渲染上的原理探索" class="headerlink" title="3.关于圆角在离屏渲染上的原理探索"></a>3.关于圆角在离屏渲染上的原理探索</h3><p><a href="https://imgchr.com/i/yUJZV0"><img src="https://s3.ax1x.com/2021/02/08/yUJZV0.png" alt="原理探索"></a><br>设置layer.cornerRadius只会设置backgroundColor和border的圆角，不会设置content的圆角；除非同时设置了layer.masksToBounds为True（对应view中的clipsToBounds属性）。</p>
<h4 id="普通渲染的逻辑"><a href="#普通渲染的逻辑" class="headerlink" title="普通渲染的逻辑"></a>普通渲染的逻辑</h4><p><a href="https://imgchr.com/i/yUJJVx"><img src="https://s3.ax1x.com/2021/02/08/yUJJVx.png" alt="普通渲染"></a><br>当subLayer绘制到屏幕上以后，就会将subLayer从帧缓存区中移除，从而节省空间</p>
<h4 id="离屏渲染的逻辑（圆角）"><a href="#离屏渲染的逻辑（圆角）" class="headerlink" title="离屏渲染的逻辑（圆角）"></a>离屏渲染的逻辑（圆角）</h4><p><a href="https://imgchr.com/i/yUJYa6"><img src="https://s3.ax1x.com/2021/02/08/yUJYa6.png" alt="圆角绘制"></a><br><a href="https://imgchr.com/i/yUJaGD"><img src="https://s3.ax1x.com/2021/02/08/yUJaGD.png" alt="绘制完成"></a></p>
<h3 id="4-常见触发离屏渲染的几种情况"><a href="#4-常见触发离屏渲染的几种情况" class="headerlink" title="4.常见触发离屏渲染的几种情况"></a>4.常见触发离屏渲染的几种情况</h3><ul>
<li>使用了mask的layer（layer.mask）</li>
<li>需要进行裁剪的layer(layer.masksToBounds/view.clipsToBounds)</li>
<li>设置了组透明度为YES，并且透明度不为1的layer(layer.allowsGroupOpacity/layer.opacity)</li>
<li>添加了阴影的layer(layer.shadow*)</li>
<li>采用了光栅化的layer(layer.shouldRasterize)</li>
<li>绘制了文字的layer(UILabel,CATextLayer,Core Text 等)</li>
</ul>
<h1 id="开发过程中怎么避免离屏渲染"><a href="#开发过程中怎么避免离屏渲染" class="headerlink" title="开发过程中怎么避免离屏渲染?"></a>开发过程中怎么避免离屏渲染?</h1><h2 id="1-避免圆角离屏渲染的手段"><a href="#1-避免圆角离屏渲染的手段" class="headerlink" title="1.避免圆角离屏渲染的手段"></a>1.避免圆角离屏渲染的手段</h2><ul>
<li>不要使用不必要的 mask，可以预处理图片为圆形，通过 Core Graphics手动绘制圆角。</li>
<li>使用中间为圆形透明的白色背景视图覆盖。但这种方式不能解决背景色为图片或渐变色的情况。</li>
<li>用 UIBezierPath 贝塞尔曲线绘制闭合带圆角的矩形，再将不带圆角的 layer 渲染成图片，添加到贝塞尔矩形中。这种方法效率更高，但是 layer 的布局一旦改变，贝塞尔曲线都需要手动地重新绘制，稍微麻烦。<h2 id="2-项目中使用圆角避免离屏渲染的方案"><a href="#2-项目中使用圆角避免离屏渲染的方案" class="headerlink" title="2.项目中使用圆角避免离屏渲染的方案"></a>2.项目中使用圆角避免离屏渲染的方案</h2></li>
<li>对于单一图层，例如UIImageView只有图片没有背景色、单纯的一个UIView等。直接使用系统提供的layer.cornorRadius；</li>
<li>能够使用中间为圆形透明的白色背景视图覆盖方式进行的，优先使用这种方法。</li>
<li>使用Core Graphics +贝塞尔曲线绘制圆角的方式，牺牲CPU计算</li>
</ul>
<h1 id="常用控件对于集中设置圆角方式的比较"><a href="#常用控件对于集中设置圆角方式的比较" class="headerlink" title="常用控件对于集中设置圆角方式的比较"></a>常用控件对于集中设置圆角方式的比较</h1><p>UIButton （设置背景图）</p>
<table>
<thead>
<tr>
<th>圆角的形式</th>
<th>产生效果</th>
<th>占用内存</th>
</tr>
</thead>
<tbody><tr>
<td>layer.cornerRadius + clipsToBounds</td>
<td>产生离屏渲染</td>
<td>内存占用10M</td>
</tr>
<tr>
<td>imageView.layer.cornerRadius + clipsToBounds</td>
<td>不发生离屏渲染</td>
<td>占用内存10.2M</td>
</tr>
<tr>
<td>Core Graphics绘制图片圆角</td>
<td>不发生离屏渲染</td>
<td>占用内存9.9M</td>
</tr>
</tbody></table>
<h2 id="3-项目中对离屏渲染的优化"><a href="#3-项目中对离屏渲染的优化" class="headerlink" title="3.项目中对离屏渲染的优化"></a>3.项目中对离屏渲染的优化</h2><ul>
<li>使用AsyncDisplayKit</li>
<li>预处理:CoreGraphics进行圆角剪切</li>
<li>视频圆角：添加一个图层盖住 （addsubview）</li>
<li>图片没有背景颜色 ，放心大胆的用layer.cornerRadius</li>
<li>阴影使用shawdowPath绘制</li>
<li>需要使用mask遮罩时，将shouldRasterize打开</li>
<li>用模糊效果，别用系统的，用开源的手动去渲染</li>
</ul>
<h4 id="Written-By-多点-移动运营研发部-童庆"><a href="#Written-By-多点-移动运营研发部-童庆" class="headerlink" title="Written By 多点-移动运营研发部-童庆"></a>Written By 多点-移动运营研发部-童庆</h4>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 内存泄漏那些事</title>
    <url>/2021/05/20/iOS%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h3>]]></content>
      <categories>
        <category>效率工具</category>
      </categories>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS客户端布局浅谈</title>
    <url>/2021/05/19/iOS%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B8%83%E5%B1%80%E6%B5%85%E8%B0%88/</url>
    <content><![CDATA[<h2 id="iOS客户端布局浅谈"><a href="#iOS客户端布局浅谈" class="headerlink" title="iOS客户端布局浅谈"></a>iOS客户端布局浅谈</h2><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>日常开发中，UI搭建、调试会占用我们大部分的时间，以至于移动端开发经常会被调侃为搭界面的。提高UI布局技术可以提高开发效率，把更多的时间放在优化、逻辑方面，而不是被界面业务绑死。</p>
<h3 id="二、UI布局约束概览"><a href="#二、UI布局约束概览" class="headerlink" title="二、UI布局约束概览"></a>二、UI布局约束概览</h3><ul>
<li>nib：nib是NeXT interface builder的英文缩写，以二进制的形式存储界面信息，是IB3.0以前的文件格式。</li>
<li>xib：xib是xml interface builder的英文缩写，是IB3.0之后苹果公司推出的新一代，以xml格式存储界面信息，在最终执行前，xib文件会被编译为nib文件。</li>
<li>storyboard：是苹果最新推出的用于在界面开发中替代xib文件的一种新技术。本质上是一个xml文件的集中管理区，不但可以描述xib单个界面的结构，还可以描述界面之间的跳转及依赖关系。主要是靠手拖，感觉像积木玩具。</li>
<li>frame：等效于代码版的storyboard，但更灵活。目前比较常用。多众多机型尺寸还是有点棘手。计算比较头疼。（据统计性能最好的布局方式！！！）</li>
<li>AutoLayout：自动布局（AutoLayout）是iOS6发布的界面布局技术，该算法的主要思想是：将基于约束系统的布局规则（本质上是表示视图布局关系的线性方程组）转化为表示规则的视图几何参数。实际上AutoLayout算法本身并非有苹果发明，只是苹果用Objective-C去实现了该算法，方便iOS开发者使用。AutoLayout有多种使用方式，如①可视化工具：Xcode的Interface Builder，②纯代码：以<a href="https://github.com/SnapKit/Masonry">Masonry</a>为代表。更多内容见自动布局 <a href="https://www.jianshu.com/p/3a872a0bfe11">Auto Layout (原理篇)</a>。</li>
<li>FlexBox：弹性布局（Flexible Box）。对，就是目前Web端最流行的布局方式（以前是盒子模型），现在APP上也能使用。此方案就扩展出很多技术，如<a href="https://github.com/facebook/yoga">Yoga</a>（最牛逼的代表，Facebook出品，衍生出很多上层方案，如跨平台的<a href="https://github.com/facebook/react-native">ReactNative</a>、Android的<a href="https://tech.meituan.com/2019/03/14/litho-use-and-principle-analysis.html">Litho</a>、iOS的Yogakit）、<a href="https://github.com/google/flexbox-layout">FlexboxLayout</a>（Android代表，Google出品）、<a href="https://github.com/zhenglibao/FlexLib">FlexLib</a>、<a href="https://github.com/FLEXTool/FLEX">FLEX</a>等。</li>
<li>swiftUI：<a href="https://developer.apple.com/xcode/swiftui/">官网</a>，苹果官方推荐。更多内容见苹果发布全新 <a href="(https://www.infoq.cn/article/Puii*HdQWCDjPzvTNcKq)">SwiftUI 框架：一次编码，五端通用</a>。<br>三、性能概览<br><a href="https://imgchr.com/i/rlDxNd"><img src="https://s3.ax1x.com/2020/12/16/rlDxNd.png" alt="iOS布局耗时测试.png"></a><br>四、Masonry<br><a href="https://imgchr.com/i/rlrgPA"><img src="https://s3.ax1x.com/2020/12/16/rlrgPA.png" alt="rlrgPA.png"></a><br><a href="https://imgchr.com/i/rlrxqU"><img src="https://s3.ax1x.com/2020/12/16/rlrxqU.png" alt="rlrxqU.png"></a></li>
</ul>
<p>1、使用前：AutoLayout关于更新的几个方法的区别</p>
<ul>
<li>setNeedsLayout：告知页面需要更新，但是不会立刻开始更新。执行后会立刻调用layoutSubviews。</li>
<li>layoutIfNeeded：告知页面布局立刻更新。所以一般都会和setNeedsLayout一起使用。如果希望立刻生成新的frame需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。</li>
<li>layoutSubviews：系统重写布局。</li>
<li>setNeedsUpdateConstraints：告知需要更新约束，但是不会立刻开始。</li>
<li>updateConstraintsIfNeeded：告知立刻更新约束。</li>
<li>updateConstraints：系统更新约束（推荐将更新约束写在这里）。<br>2、基本使用</li>
<li>mas_makeConstraints:添加约束。</li>
<li>mas_updateConstraints：更新约束、亦可添加新约束。</li>
<li>mas_remakeConstraints：重置之前的约束。<br>3、常用宏定义<br>Masonry使用链式方式编程，有定义一些宏来方便开发，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define offset(...)                      mas_offset(__VA_ARGS__)#define equalTo(...)                     mas_equalTo(__VA_ARGS__)#define greaterThanOrEqualTo(...)        mas_greaterThanOrEqualTo(__VA_ARGS__)#define lessThanOrEqualTo(...)           mas_lessThanOrEqualTo(__VA_ARGS__)</span><br></pre></td></tr></table></figure>
<p>如：<br>// make.left 以下两种写法等价</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make.left.equalTo(superView.mas_left).offset(10);</span><br><span class="line">make.left.mas_equalTo(10);</span><br><span class="line">make.left.mas_equalTo(superView.mas_left).mas_offset(10);</span><br></pre></td></tr></table></figure>
<p>4、约束属性的关系<br>约束属性有三种关系，分别是等于，大于，小于。</p>
<ul>
<li><p>等于（equivalent to NSLayoutRelationEqual）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//.equalTo</span><br><span class="line">// view.width = 60</span><br><span class="line">make.width.mas_equalTo(60);</span><br></pre></td></tr></table></figure></li>
<li><p>小于（equivalent to NSLayoutRelationLessThanOrEqual）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//.lessThanOrEqualTo</span><br><span class="line">// view.width &lt;= 120</span><br><span class="line">make.width.lessThanOrEqualTo(120);</span><br></pre></td></tr></table></figure></li>
<li><p>大于（equivalent to NSLayoutRelationGreaterThanOrEqual）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//.greaterThanOrEqualTo </span><br><span class="line">// view.width &gt;= 60</span><br><span class="line">make.width.lessThanOrEqualTo(60);</span><br></pre></td></tr></table></figure>
<p>5、常见写法<br>对于自动布局我们只需要设置好view的position，包括X轴和Y轴上的位置，以及view的长宽即可。<br>Masonry除了设置单个约束以外，还提供了很多方便的复合约束设置方式。以下分别介绍单个约束属性设置方式和复合约束设置方式。<br>6、长度和宽度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// make width = 60</span><br><span class="line">make.width.mas_equalTo(60);</span><br><span class="line">// make height = 60</span><br><span class="line">make.height.mas_equalTo(60);</span><br><span class="line">// make height = 60, width = 60</span><br><span class="line">make.size.equalTo(CGSizeMake(60, 60));</span><br><span class="line">// make view1.height = view2.height view1.width = view2.width</span><br><span class="line">make.size.mas_equalTo(view2);</span><br><span class="line">// make width and height greater than or equal to view2</span><br><span class="line">make.size.greaterThanOrEqualTo(view2);</span><br><span class="line">// make width = superview.width + 100, height = superview.height - 50</span><br><span class="line">make.size.equalTo(superview).sizeOffset(CGSizeMake(100, -50));</span><br></pre></td></tr></table></figure>
<p>7、边距对齐（位置设置）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make.left.mas_equalTo(superView.mas_left).mas_offset(10);</span><br><span class="line">make.left.mas_greaterThanOrEqualTo(10);</span><br></pre></td></tr></table></figure>
<p>约束的链式写法中，不包含其他相对的view时，默认为其superview view.left 等于 label.lefet，以下三种写法等价：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make.left.mas_equalTo(view.superview.mas_left).offset(10);</span><br><span class="line">make.left.mas_equalTo(view.superview).offset(10);</span><br></pre></td></tr></table></figure>
<p>view.left 大于等于 label.left，以下两种写法等同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make.left.greaterThanOrEqualTo(label);</span><br><span class="line">make.left.greaterThanOrEqualTo(label.mas_left);</span><br></pre></td></tr></table></figure>
<p>上下左右四个边缘等于父视图的边缘，也就是top, left, bottom, right equal view2，以下三种写法等同（复合约束写法）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make.edges.equalTo(superview);</span><br><span class="line">make.edges.equalTo(superview).insets(UIEdgeInsetsMake(0, 0, 0, 0))</span><br><span class="line">make.left.right.and.bottom.equalTo(superview);</span><br></pre></td></tr></table></figure>
<p>PS：如果top, left, bottom, right的边距各自不同：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// make top = superview.top + 5, left = superview.left + 10,</span><br><span class="line">// bottom = superview.bottom - 15, right = superview.right - 20</span><br><span class="line">make.edges.equalTo(superview).insets(UIEdgeInsetsMake(5, 10, 15, 20))</span><br></pre></td></tr></table></figure>
<p>8、中心对齐（位置设置）<br>X轴上中心和superview的X轴上中心对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make.centerX.equalTo(superview.mas_centerX).offet(0)</span><br><span class="line">make.centerX.equalTo(superview.mas_centerX) </span><br><span class="line">make.centerX.equalTo(superview)</span><br></pre></td></tr></table></figure>
<p>X轴和Y轴中心对齐</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make.center.equalTo(superview);</span><br><span class="line">make.center.equalTo(superview).centerOffset(CGPointMake(0, 0));</span><br></pre></td></tr></table></figure>
<p>PS：如果X轴和Y轴上的中心对齐各自不同：</p>
<figure class="highlight plaintext"><figcaption><span>make centerX </span></figcaption><table><tr><td class="code"><pre><span class="line">make.center.equalTo(superview).centerOffset(CGPointMake(-5, 10));</span><br></pre></td></tr></table></figure>
<p>9、约束数字值<br>Masonry允许将宽度和高度设置为常量值。如果要将视图设置一个最小和最大宽度时，可以在block中同时设定：<br>//width &gt;= 200 &amp;&amp; width &lt;= 400</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make.width.greaterThanOrEqualTo(@200);</span><br><span class="line">make.width.lessThanOrEqualTo(@400);</span><br></pre></td></tr></table></figure>
<p>Masonry不允许把边距属性（left，top，right，bottom，centerX，centerY）的约束设置为常量值，如果设置了，会默认这些属性是相对父视图设置的。</p>
<figure class="highlight plaintext"><figcaption><span>view.left </span></figcaption><table><tr><td class="code"><pre><span class="line">make.left.equalTo(@10)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//creates view.left = view.superview.left + 10</span><br><span class="line">make.left.lessThanOrEqualTo(@10)</span><br></pre></td></tr></table></figure>
<p>// 或者使用mas_equalTo这种时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make.top.mas_equalTo(42);</span><br><span class="line">make.height.mas_equalTo(20);</span><br><span class="line">make.size.mas_equalTo(CGSizeMake(50, 100));</span><br><span class="line">make.edges.mas_equalTo(UIEdgeInsetsMake(10, 0, 10, 0));</span><br><span class="line">make.left.mas_equalTo(view).mas_offset(UIEdgeInsetsMake(10, 0, 10, 0));</span><br></pre></td></tr></table></figure>
<p>10、优先级<br>自定义优先级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .priority allows you to specify an exact priority  </span><br><span class="line">make.top.equalTo(label.mas_left).with.priority(600);</span><br></pre></td></tr></table></figure>
<p>高优先级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .priorityHigh equivalent to **UILayoutPriorityDefaultHigh**  </span><br><span class="line">make.left.equalTo(label.mas_left).with.priorityHigh();</span><br></pre></td></tr></table></figure>
<p>中等优先级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .priorityMedium is half way between high and low  </span><br><span class="line">make.left.equalTo(label.mas_left).with.priorityMedium();</span><br></pre></td></tr></table></figure>
<p>低优先级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .priorityLow equivalent to **UILayoutPriorityDefaultLow**</span><br><span class="line">make.left.greaterThanOrEqualTo(label.mas_left).with.priorityLow();</span><br></pre></td></tr></table></figure>
<p>11、equalTo 和 mas_equalTo的区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__)))</span><br><span class="line">#define mas_greaterThanOrEqualTo(...) greaterThanOrEqualTo(MASBoxValue((__VA_ARGS__)))</span><br><span class="line">#define mas_lessThanOrEqualTo(...) lessThanOrEqualTo(MASBoxValue((__VA_ARGS__)))</span><br><span class="line">#define mas_offset(...) valueOffset(MASBoxValue((__VA_ARGS__)))</span><br></pre></td></tr></table></figure>
<p>得出结论：mas_equalTo只是对其参数进行了一个BOX(装箱) 操作，目前支持的类型：数值类型（NSNumber）、 点（CGPoint）、大小（CGSize）、边距（UIEdgeInsets），而equalTo：这个方法不会对参数进行包装。<br>12、多个视图（大于2）有相同规则的布局方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** NSArray+MASAdditions.h</span><br><span class="line"></span><br><span class="line"> *  多个控件固定间隔的等间隔排列，变化的是控件的长度或者宽度值</span><br><span class="line"> *</span><br><span class="line"> *  @param axisType        轴线方向</span><br><span class="line"> *  @param fixedSpacing    间隔大小</span><br><span class="line"> *  @param leadSpacing     头部间隔</span><br><span class="line"> *  @param tailSpacing     尾部间隔</span><br><span class="line"> */- (void)mas_distributeViewsAlongAxis:(MASAxisType)axisType </span><br><span class="line">                    withFixedSpacing:(CGFloat)fixedSpacing l</span><br><span class="line">                          eadSpacing:(CGFloat)leadSpacing </span><br><span class="line">                         tailSpacing:(CGFloat)tailSpacing;</span><br><span class="line">/**</span><br><span class="line"> *  多个固定大小的控件的等间隔排列,变化的是间隔的空隙</span><br><span class="line"> *</span><br><span class="line"> *  @param axisType        轴线方向</span><br><span class="line"> *  @param fixedItemLength 每个控件的固定长度或者宽度值</span><br><span class="line"> *  @param leadSpacing     头部间隔</span><br><span class="line"> *  @param tailSpacing     尾部间隔</span><br><span class="line"> */- (void)mas_distributeViewsAlongAxis:(MASAxisType)axisType </span><br><span class="line">                 withFixedItemLength:(CGFloat)fixedItemLength </span><br><span class="line">                         leadSpacing:(CGFloat)leadSpacing </span><br><span class="line">                         tailSpacing:(CGFloat)tailSpacing;</span><br></pre></td></tr></table></figure>
<p>eg1：水平方向排列、固定控件间隔、控件长度不定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)test_masonry_horizontal_fixSpace &#123;</span><br><span class="line">    // 实现masonry水平固定间隔方法</span><br><span class="line">    [self.masonryViewArray mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedSpacing:30 leadSpacing:10 tailSpacing:10];   </span><br><span class="line">    // 设置array的垂直方向的约束</span><br><span class="line">    [self.masonryViewArray mas_makeConstraints:^(MASConstraintMaker *make) &#123;   </span><br><span class="line">        make.top.equalTo(150);</span><br><span class="line">        make.height.equalTo(80);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/rlWKn1"><img src="https://s3.ax1x.com/2020/12/16/rlWKn1.png" alt="rlWKn1.png"></a></p>
</li>
</ul>
<p>eg2：水平方向排列、固定控件长度、控件间隔不定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)test_masonry_horizontal_fixItemWidth &#123;</span><br><span class="line">    // 实现masonry水平固定控件宽度方法</span><br><span class="line">    [self.masonryViewArray mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedItemLength:80 leadSpacing:10 tailSpacing:10];  </span><br><span class="line"> // 设置array的垂直方向的约束</span><br><span class="line">[self.maViewArray mas_makeConstraints:^(MASConstraintMaker *make) &#123;      </span><br><span class="line">        make.top.equalTo(150);</span><br><span class="line">        make.height.equalTo(80);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/rlWY1H"><img src="https://s3.ax1x.com/2020/12/16/rlWY1H.png" alt="rlWY1H.png"></a><br>eg3：垂直方向排列、固定控件间隔、控件高度不定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)test_masonry_vertical_fixSpace &#123;</span><br><span class="line">    // 实现masonry垂直固定控件高度方法</span><br><span class="line">    [self.masonryViewArray mas_distributeViewsAlongAxis:MASAxisTypeVertical withFixedSpacing:30 leadSpacing:10 tailSpacing:10];</span><br><span class="line">// 设置array的水平方向的约束</span><br><span class="line">[self.masonryViewArray mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.left.equalTo(150);</span><br><span class="line">        make.width.equalTo(80);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/rlWanI"><img src="https://s3.ax1x.com/2020/12/16/rlWanI.png" alt="rlWanI.png"></a><br>eg4：垂直方向排列、固定控件高度、控件间隔不定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)test_masonry_vertical_fixItemWidth &#123;</span><br><span class="line">    // 实现masonry垂直方向固定控件高度方法</span><br><span class="line">    [self.masonryViewArray mas_distributeViewsAlongAxis:MASAxisTypeVertical withFixedItemLength:80 leadSpacing:10 tailSpacing:10];</span><br><span class="line">    // 设置array的水平方向的约束</span><br><span class="line">    [self.masonryViewArray mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.left.equalTo(150);</span><br><span class="line">        make.width.equalTo(80);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/rlWBAf"><img src="https://s3.ax1x.com/2020/12/16/rlWBAf.png" alt="rlWBAf.png"></a><br>13、Content Compression Resistance和Content Hugging<br><a href="https://imgchr.com/i/rlWccj"><img src="https://s3.ax1x.com/2020/12/16/rlWccj.png" alt="rlWccj.png"></a><br>// label1: 位于左上角</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[_label1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.equalTo(_contentView1.mas_top).with.offset(5);</span><br><span class="line">    make.left.equalTo(_contentView1.mas_left).with.offset(2);</span><br><span class="line">    make.height.equalTo(@40);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>// label2: 位于右上角</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[_label2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    //左边贴着label1，间隔2</span><br><span class="line">    make.left.equalTo(_label1.mas_right).with.offset(2);</span><br><span class="line">    //上边贴着父view，间隔5</span><br><span class="line">    make.top.equalTo(_contentView1.mas_top).with.offset(5);</span><br><span class="line">    //右边的间隔保持大于等于2，注意是lessThanOrEqual</span><br><span class="line">    //这里的“lessThanOrEqualTo”放在从左往右的X轴上考虑会更好理解。</span><br><span class="line">    //即：label2的右边界的X坐标值“小于等于”containView的右边界的X坐标值。</span><br><span class="line">    make.right.lessThanOrEqualTo(_contentView1.mas_right).with.offset(-2);</span><br><span class="line">    make.height.equalTo(@40);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>//设置label1的content hugging 为1000</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[_label1 setContentHuggingPriority:UILayoutPriorityRequired</span><br><span class="line">                           forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line"></span><br><span class="line">//设置label1的content compression 为1000</span><br><span class="line">[_label1 setContentCompressionResistancePriority:UILayoutPriorityRequired                                       forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line"></span><br><span class="line">//设置右边的label2的content hugging 为1000</span><br><span class="line">[_label2 setContentHuggingPriority:UILayoutPriorityRequired</span><br><span class="line">                           forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line"></span><br><span class="line">//设置右边的label2的content compression 为250</span><br><span class="line">[_label2 setContentCompressionResistancePriority:UILayoutPriorityDefaultLow                                         forAxis:UILayoutConstraintAxisHorizontal];</span><br></pre></td></tr></table></figure>
<p>五、UIStackVIew</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UILayoutConstraintAxis) &#123;</span><br><span class="line">UILayoutConstraintAxisHorizontal = 0,//水平</span><br><span class="line">UILayoutConstraintAxisVertical = 1//垂直</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, UIStackViewAlignment) &#123;</span><br><span class="line">UIStackViewAlignmentFill,//子视图填充StackView</span><br><span class="line">UIStackViewAlignmentLeading,//子视图左对齐（axis为垂直方向而言）</span><br><span class="line">UIStackViewAlignmentTop = UIStackViewAlignmentLeading,//子视图顶部对齐（axis为水平方向而言）</span><br><span class="line">UIStackViewAlignmentFirstBaseline, // 按照第一个子视图的文字的第一行对齐，同时保证高度最大的子视图底部对齐（只在axis为水平方向有效）</span><br><span class="line">UIStackViewAlignmentCenter,//子视图居中对齐</span><br><span class="line">UIStackViewAlignmentTrailing,//子视图右对齐(axis为垂直方向而言）</span><br><span class="line">UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing,//子视图底部对齐（axis为水平方向而言）</span><br><span class="line">UIStackViewAlignmentLastBaseline, // 按照最后一个子视图的文字的最后一行对齐，同时保证高度最大的子视图顶部对齐（只在axis为水平方向有效）</span><br><span class="line">&#125; NS_ENUM_AVAILABLE_IOS(9_0);</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, UIStackViewDistribution) &#123;</span><br><span class="line">UIStackViewDistributionFill = 0, </span><br><span class="line">UIStackViewDistributionFillEqually, </span><br><span class="line">UIStackViewDistributionFillProportionally,</span><br><span class="line">UIStackViewDistributionEqualSpacing, </span><br><span class="line">UIStackViewDistributionEqualCentering,&#125; NS_ENUM_AVAILABLE_IOS(9_0);</span><br></pre></td></tr></table></figure>
<h4 id="Written-By-多点-移动运营研发部-贺波"><a href="#Written-By-多点-移动运营研发部-贺波" class="headerlink" title="Written By 多点-移动运营研发部-贺波"></a>Written By 多点-移动运营研发部-贺波</h4>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>布局漫谈</tag>
      </tags>
  </entry>
  <entry>
    <title>网络知识小结-理论篇</title>
    <url>/2021/05/19/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93-%E7%90%86%E8%AE%BA%E7%AF%87/</url>
    <content><![CDATA[<h5 id="如今互联网时代，差不多每人都有一个终端能够浏览网上的信息。那这些终端是怎么连接到网上并浏览信息的呢？要想了解这些知识，就要从网络的基础知识开始说起。"><a href="#如今互联网时代，差不多每人都有一个终端能够浏览网上的信息。那这些终端是怎么连接到网上并浏览信息的呢？要想了解这些知识，就要从网络的基础知识开始说起。" class="headerlink" title="如今互联网时代，差不多每人都有一个终端能够浏览网上的信息。那这些终端是怎么连接到网上并浏览信息的呢？要想了解这些知识，就要从网络的基础知识开始说起。"></a>如今互联网时代，差不多每人都有一个终端能够浏览网上的信息。那这些终端是怎么连接到网上并浏览信息的呢？要想了解这些知识，就要从网络的基础知识开始说起。</h5><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><h5 id="nbsp-nbsp-nbsp-nbsp-互联网的起源可以追溯到1960年代美国联邦政府委托进行的一项研究，目的是创建容错与电脑网络的通信。互联网的前身ARPANET最初在1980年代作为区域学术和军事网络连接的骨干。"><a href="#nbsp-nbsp-nbsp-nbsp-互联网的起源可以追溯到1960年代美国联邦政府委托进行的一项研究，目的是创建容错与电脑网络的通信。互联网的前身ARPANET最初在1980年代作为区域学术和军事网络连接的骨干。" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;互联网的起源可以追溯到1960年代美国联邦政府委托进行的一项研究，目的是创建容错与电脑网络的通信。互联网的前身ARPANET最初在1980年代作为区域学术和军事网络连接的骨干。"></a>&nbsp;&nbsp;&nbsp;&nbsp;互联网的起源可以追溯到1960年代美国联邦政府委托进行的一项研究，目的是创建容错与电脑网络的通信。互联网的前身ARPANET最初在1980年代作为区域学术和军事网络连接的骨干。</h5><h5 id="nbsp-nbsp-nbsp-nbsp-1974年，罗伯特·卡恩和文顿·瑟夫提出TCP-IP，定义在电脑网络之间传送报文的方法。1986年，美国国家科学基金会创建超级电脑中心与学术机构之间互联基于TCP-IP技术的骨干网络NSFNET，速度由最初的56kbit-s，接着为T1（1-5Mbit-s），最后发展至T3（45Mbit-s）。商业互联网服务提供商（ISP）出现于1980年代末和1990年代初。ARPANET于1990年退役。"><a href="#nbsp-nbsp-nbsp-nbsp-1974年，罗伯特·卡恩和文顿·瑟夫提出TCP-IP，定义在电脑网络之间传送报文的方法。1986年，美国国家科学基金会创建超级电脑中心与学术机构之间互联基于TCP-IP技术的骨干网络NSFNET，速度由最初的56kbit-s，接着为T1（1-5Mbit-s），最后发展至T3（45Mbit-s）。商业互联网服务提供商（ISP）出现于1980年代末和1990年代初。ARPANET于1990年退役。" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;1974年，罗伯特·卡恩和文顿·瑟夫提出TCP/IP，定义在电脑网络之间传送报文的方法。1986年，美国国家科学基金会创建超级电脑中心与学术机构之间互联基于TCP/IP技术的骨干网络NSFNET，速度由最初的56kbit/s，接着为T1（1.5Mbit/s），最后发展至T3（45Mbit/s）。商业互联网服务提供商（ISP）出现于1980年代末和1990年代初。ARPANET于1990年退役。"></a>&nbsp;&nbsp;&nbsp;&nbsp;1974年，罗伯特·卡恩和文顿·瑟夫提出TCP/IP，定义在电脑网络之间传送报文的方法。1986年，美国国家科学基金会创建超级电脑中心与学术机构之间互联基于TCP/IP技术的骨干网络NSFNET，速度由最初的56kbit/s，接着为T1（1.5Mbit/s），最后发展至T3（45Mbit/s）。商业互联网服务提供商（ISP）出现于1980年代末和1990年代初。ARPANET于1990年退役。</h5><h4 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h4><h5 id="nbsp-nbsp-nbsp-nbsp-网络通信的实现，分了好几层，每一层都有自己特有的功能，而且每一层都靠下一层的支持。用户接触到，只是最上面的一层，称为应用层。如果要深入理解互联网，必须从最下层开始，自下而上理解每一层的功能。"><a href="#nbsp-nbsp-nbsp-nbsp-网络通信的实现，分了好几层，每一层都有自己特有的功能，而且每一层都靠下一层的支持。用户接触到，只是最上面的一层，称为应用层。如果要深入理解互联网，必须从最下层开始，自下而上理解每一层的功能。" class="headerlink" title="&nbsp;&nbsp;&nbsp;&nbsp;网络通信的实现，分了好几层，每一层都有自己特有的功能，而且每一层都靠下一层的支持。用户接触到，只是最上面的一层，称为应用层。如果要深入理解互联网，必须从最下层开始，自下而上理解每一层的功能。"></a>&nbsp;&nbsp;&nbsp;&nbsp;网络通信的实现，分了好几层，每一层都有自己特有的功能，而且每一层都靠下一层的支持。用户接触到，只是最上面的一层，称为应用层。如果要深入理解互联网，必须从最下层开始，自下而上理解每一层的功能。</h5><h5 id="网络分层模型有三种："><a href="#网络分层模型有三种：" class="headerlink" title="网络分层模型有三种："></a>网络分层模型有三种：</h5><blockquote>
<blockquote>
<p>网络分层</p>
<blockquote>
<p>OSI七层<br>理论五层<br>TCP/IP 四层模型</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h5 id="分层模型概览："><a href="#分层模型概览：" class="headerlink" title="分层模型概览："></a>分层模型概览：</h5><blockquote>
<h3 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h3><blockquote>
<p>应用层<br>表示层<br>回话层<br>传输层<br>网络层<br>数据链路层<br>物理层</p>
</blockquote>
</blockquote>
<blockquote>
<p>理论五层</p>
<blockquote>
<p>应用层<br>传输层<br>网络层<br>数据链路层<br>物理层  </p>
</blockquote>
</blockquote>
<blockquote>
<p>TCP/IP 四层模型</p>
<blockquote>
<p>应用层<br>传输层<br>网际层<br>网络接口层</p>
</blockquote>
</blockquote>
<p><img src="https://s3.ax1x.com/2020/12/27/r5s32n.png" alt="网络分层图"></p>
<h3 id="基于理论五层"><a href="#基于理论五层" class="headerlink" title="基于理论五层"></a><strong>基于理论五层</strong></h3><p>各层的作用如下：</p>
<ul>
<li>应用层(Application Layer)<ul>
<li>直接为用户的应用进程提供服务</li>
<li>常见的协议有 HTTP、HTTPS、SMTP、TELNET等</li>
</ul>
</li>
<li>传输层(Transport Layer)<ul>
<li>传输层任务是为应用层进行通信的两个进程之间提供一个可靠的 <strong>端到端</strong> 服务，使它们看不到传输层以下的数据通信的细节。</li>
<li><strong>端到端</strong> 的意思是数据来自某个<strong>端口</strong>，再传送给指定的<strong>端口</strong></li>
<li><strong>端口</strong>：一个0到65535间的整数，用来指定特定应用程序</li>
<li>常见的协议有TCP、UDP等</li>
</ul>
</li>
<li>网络层<ul>
<li>网络层的任务是选择合适的路由，使分组能够准确的按照地址找到目的地，并给交付目的地的传输层。</li>
<li>网络层协议为IP协议</li>
</ul>
</li>
<li>数据链路层<ul>
<li>数据链路层是将数据组合为一个个的<strong>帧</strong>，确定电信号的数据包格式。</li>
<li>数据链路层的协议为<strong>以太网</strong>协议</li>
</ul>
</li>
<li>物理层<ul>
<li>物理层定义了把电脑之间连接起来所用设备的标准，在网络中的网络信号都是通过<strong>0和1</strong>的电信号进行传输的。</li>
</ul>
</li>
</ul>
<p>越下面的层，越靠近硬件；越上面的层，越靠近用户。</p>
<h3 id="理论解读"><a href="#理论解读" class="headerlink" title="理论解读"></a>理论解读</h3><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul>
<li>数字信号通过编码器转化为电信号</li>
<li>电信号通过滤波器、模拟信号转换器译码成数字信号</li>
</ul>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ul>
<li><p>以太网协议即指导文档规范</p>
<ul>
<li>规定一组电信号构成一个数据包，叫做**帧(frame)**，每一帧分为两部分：标头（Head）和数据（Data）。</li>
<li>标头长度固定，18个字节（1Byte=8bit），数据最短46字节，最长1500字节，因此总数据包最短就是64字节，最长就是1518字节。</li>
<li>标头就是数据包的一些说明项，比如：发送者MAC地址，接收者MAC地址，数据类型等；数据就是发送的具体内容。</li>
<li>由于链路层存在MTU（最大传输单元 Maximum transmission unit）的限制，如果网络层的报文超过MTU，那就必须进行分片。</li>
</ul>
</li>
<li><p>网卡地址（MAC)</p>
<ul>
<li>mac地址全世界独一无二，长度是48个二进制位，通常用12个十六进制数表示。</li>
</ul>
</li>
<li><p>广播</p>
<ul>
<li>一块网卡怎么会知道另一块网卡的MAC地址，<strong>ARP协议，地址解析协议（Address Resolution Protocol）</strong><ul>
<li>用于根据给定<strong>网络层地址</strong>，IPv4或IPv6，查找其对应的<strong>数据链路层地址</strong>，例如MAC地址；这里用到了<strong>ARP 高速缓存</strong>，在同一局域网内，通过ARP高速缓存，找与IP地址对应的MAC地址。</li>
<li> ARP 协议是局域网内部的协议。如果局域网中找不到对应的MAC地址，就把数据包传送到两个子网连接处的网关，让网关去处理。</li>
</ul>
</li>
<li>有了接收方MAC地址，怎么发送过去<ul>
<li>向本局域网内的所有计算机发广播，让接收到广播的每台计算机自己去判断，是否为接收方。</li>
<li>如果局域网内计算机太多，如果每台都在发报文、接报文，那会引起广播风暴。那如果避免这种情况的出现，就需要引入一套新的地址。这就导致了网络层的出现，网络层定义出网络地址，网络地址能够区分不同的计算机是否属于同一个<strong>子网络</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>网络地址的制定标准是<strong>IP协议</strong><ul>
<li>通过IP协议定义出来的地址是IP地址，现有标准是IPV4和IPV6。</li>
<li>通过IP地址，如何判断两台计算机是否属于同一个子网络？这就需要子网掩码。两个IP地址与子网掩码进行<strong>按位与</strong>运算，结果相同则在同一子网，否则不在。</li>
<li>IP数据包，根据IP协议发送的数据。也分为<strong>标头</strong>和<strong>数据</strong>两个部分，其中标头长度是20-60字节（IPV6固定为40字节），整个数据包的总长度最大为65535（2^16）字节，数据包就是 65535 -（20~60）（IPV6是固定的40）。</li>
<li>源IP地址，目的IP地址，8未TTL，time to live，生存时间等。</li>
</ul>
</li>
</ul>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ul>
<li><p>传输的数据包到底给谁用？<strong>传输层</strong></p>
<ul>
<li>传输层的功能，就是建立<strong>端口到端口</strong>的通信。相比于传输层，网络层则是建立<strong>主机到主机</strong>的通信。只要确定主机和端口，就能实现程序之间的交流。Unix系统把主机和端口，叫做<strong>套接字（socket）</strong>。</li>
</ul>
</li>
<li><p>UDP</p>
<ul>
<li>UDP协议：用户数据报协议。数据报传输需要加入端口信息，UDP协议就由此产生。<ul>
<li>UDP协议比较简单，容易实现，但缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。不检查数据包是否到达、网络是否拥塞等情况。</li>
<li>格式几乎就是在数据前面加上端口号。</li>
<li>16位源端口号+16位目的端口号+16位UDP长度+16位UDP校验+数据（可有可无），这样UDP的标头，固定是8字节（64位）。<img src="https://s3.ax1x.com/2021/01/06/sVtLUP.png" alt="UDP数据包"></li>
<li>再加上IP包之后，整个以太网数据包就是：<img src="https://s3.ax1x.com/2021/01/06/sVU6Fx.png" alt="以太网数据包"></li>
</ul>
</li>
<li>UDP中一个包的大小最大能有多大<ul>
<li>局域网环境下，建议将UDP数据控制在1472字节以下。为什么是<strong>1472字节</strong>？以太网的数据帧长度必须在46-1500字节之间，这是以太网的物理特性决定的，这个1500字节是链路层的MTU（最大传输单元）。这个MTU是链路层的数据区，不包含链路层的首部和尾部的18个字节（发送者MAC地址+接收者MAC地址+数据类型，各6个字节），因为以太网协议帧最长是1518字节。而网络层IP数据报有最小20字节的限制，所以IP数据包的数据区长度最大是1480字节。而这1480字节就是存放TCP报文或UDP数据报的。因为UDP数据报的首部8字节，所以UDP数据报的数据区最大长度为1472字节。基于数据尽量不分片的原则，建议UDP的数据控制在1472字节以下为好。</li>
<li>Internet编程时，建议将UDP数据控制在548字节以下。ipv4协议规定ip层的最小重组缓冲区大小为576字节。由于UDP的标头是8字节，IP包的标头是20-60字节，所以UDP的数据长度控制在<strong>548字节（576-8-20）</strong>以内。</li>
</ul>
</li>
</ul>
</li>
<li><p>TCP协议：传输控制协议</p>
<ul>
<li>由于UDP协议的不可靠性，TCP协议就此诞生，与UDP不同的是TCP的确认机制，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</li>
<li>TCP还提供<strong>拥塞控制</strong>用于缓解<strong>网络拥堵</strong>。</li>
<li>TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。<img src="https://s3.ax1x.com/2021/02/20/y4hyUs.png" alt="TCP数据格式"></li>
<li>TCP标头在20-60字节之间，除了源端口号和目的端口号之外，还包含了序号、确认号等各种信息，用于保证可靠连接与数据重发。</li>
<li>TCP数据包也是内嵌在IP数据包的数据部分，TCP数据包没有长度限制，理论上可以无限长，但为了不分割，通常TCP数据包的长度不超过IP数据包的长度。<img src="https://s3.ax1x.com/2021/02/20/y4hTa9.png" alt="y4hTa9.png"></li>
<li>发送数据拼装过程<img src="https://s3.ax1x.com/2021/02/20/y44VsS.png" alt="拼装过程"></li>
</ul>
</li>
</ul>
<h6 id="TCP为什么可靠"><a href="#TCP为什么可靠" class="headerlink" title="TCP为什么可靠"></a>TCP为什么可靠</h6><ul>
<li>确认应答机制<ul>
<li>TCP中将每个字节的数据都进行了编号，就是同步序列号（SYN）</li>
</ul>
</li>
<li>超时重传机制<ul>
<li>有了序列号之后，为了准确送达数据，就有了超时重传。在发送端数据发出后，一定时间没有接收到确认，发送端就会重传数据。没有接收确认的原因，有可能是数据丢失，还有可能是网络拥堵，如果是网络拥堵，重传的数据，对于接收端是重复数据，这时接收端就需要根据序列号进行去重。</li>
</ul>
</li>
<li>流量控制<ul>
<li>接收处理数据的速度是一定的，如果发送端发送数据的速度太快，就有可能把接收端的缓存打满，如果接收端不进行流量控制，就会导致数据丢包的现象。TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制就叫流量控制。</li>
<li>TCP的首部有控制窗口大小的字段，里面存放着窗口大小信息。</li>
<li>接收端会根据缓冲区大小，灵活调整流量窗口大小</li>
<li>如果接收端缓冲区满了,发送端不再发送数据，发送端需要定期发送一个试探窗口，目的是为了接收端的缓冲区有空间时及时告诉给发送端。</li>
</ul>
</li>
<li>拥塞窗口<ul>
<li>拥塞控制是防止过多的数据注入到网络中，防止网络中的路由器或链路过载，是一个全局性的过程</li>
<li>拥塞控制机制<ul>
<li>慢开始</li>
<li>拥塞控制</li>
<li>快重传</li>
<li>快恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul>
<li>规定应用程序的数据格式，例如：Email、WWW、FTP、HTTP(s)等</li>
<li>直接面对用户</li>
<li>应用数据直接放TCP或UDP数据包的数据部分<img src="https://s3.ax1x.com/2021/02/20/y44QGq.png" alt="y44QGq.png"></li>
</ul>
<h3 id="Wireshark-实践"><a href="#Wireshark-实践" class="headerlink" title="Wireshark 实践"></a>Wireshark 实践</h3><h5 id="UDP数据包分析"><a href="#UDP数据包分析" class="headerlink" title="UDP数据包分析"></a>UDP数据包分析</h5><ul>
<li>Wireshark 抓UDP包<img src="https://s3.ax1x.com/2021/02/20/y4LTOI.png" alt="UDP数据包"></li>
<li>从抓包数据可以看出UDP协议数据是封装了要传输的数据和UDP标头数据<img src="https://s3.ax1x.com/2021/02/20/y4LxpQ.png" alt="UDP数据详情"></li>
<li>IP协议数据包<img src="https://s3.ax1x.com/2021/02/20/y4Ogjs.png" alt="IP协议"></li>
<li>以太网协议数据包<img src="https://s3.ax1x.com/2021/02/20/y4Ogjs.png" alt="以太网数据包"></li>
</ul>
<h5 id="TCP数据包分析"><a href="#TCP数据包分析" class="headerlink" title="TCP数据包分析"></a>TCP数据包分析</h5><h6 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a><strong>TCP 三次握手</strong></h6><ul>
<li>TCP三次握手 <img src="https://s3.ax1x.com/2021/02/20/y4XLRg.png" alt="三次握手"></li>
<li>TCP第一次握手<img src="https://s3.ax1x.com/2021/02/20/y4jlWD.png" alt="第一次握手"></li>
<li>TCP第二次握手<img src="https://s3.ax1x.com/2021/02/20/y4jhfU.png" alt="第二次握手"></li>
<li>TCP第三次握手<img src="https://s3.ax1x.com/2021/02/20/y4v3NV.png" alt="第三次握手"></li>
<li>TCP数据<img src="https://s3.ax1x.com/2021/02/20/y4vau9.png" alt="TCP数据"></li>
</ul>
<h6 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a><strong>TCP 四次挥手</strong></h6><ul>
<li>客户端向服务端发送关闭请求</li>
<li>服务端接受到请求向客户端发送待关闭通知</li>
<li>服务端发送结束请求，并进入LAST_ACK状态，等待来自客户端的最后一个ACK。</li>
<li>客户端收到服务端的已关闭信息之后发送一个确认包，并进入TIME_WAIT状态。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/4WT7gnXxNk2C_iMRCgA_jA">https://mp.weixin.qq.com/s/4WT7gnXxNk2C_iMRCgA_jA</a></li>
<li><a href="https://juejin.im/post/6876860213991833613?utm_source=gold_browser_extension">https://juejin.im/post/6876860213991833613?utm_source=gold_browser_extension</a></li>
<li><a href="https://juejin.im/entry/6844903666445451272">https://juejin.im/entry/6844903666445451272</a></li>
<li><a href="https://www.cnblogs.com/steven520213/p/8005258.html">https://www.cnblogs.com/steven520213/p/8005258.html</a></li>
<li><a href="http://www.9upk.com/article/2537.html">http://www.9upk.com/article/2537.html</a></li>
<li><a href="https://mp.weixin.qq.com/s/4WT7gnXxNk2C_iMRCgA_jA">https://mp.weixin.qq.com/s/4WT7gnXxNk2C_iMRCgA_jA</a></li>
<li><a href="https://blog.csdn.net/wojiaopanpan/article/details/69944970">https://blog.csdn.net/wojiaopanpan/article/details/69944970</a></li>
<li><a href="https://mp.weixin.qq.com/s/9llz-yGUbYgP2kmcwwkJdA">https://mp.weixin.qq.com/s/9llz-yGUbYgP2kmcwwkJdA</a></li>
<li><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">https://hit-alibaba.github.io/interview/basic/network/TCP.html</a></li>
<li><a href="https://github.com/facebookarchive/SocketRocket">https://github.com/facebookarchive/SocketRocket</a></li>
<li><a href="https://github.com/pkyeck/socket.IO-objc">https://github.com/pkyeck/socket.IO-objc</a></li>
<li><a href="https://github.com/robbiehanson/CocoaAsyncSocket">https://github.com/robbiehanson/CocoaAsyncSocket</a></li>
<li><a href="https://github.com/socketio/socket.io">https://github.com/socketio/socket.io</a></li>
<li><a href="https://github.com/CoderJackyHuang/iOS-Socket-C-Version">https://github.com/CoderJackyHuang/iOS-Socket-C-Version</a></li>
<li><a href="https://juejin.cn/post/6844903958624878606">https://juejin.cn/post/6844903958624878606</a></li>
<li><a href="https://blog.csdn.net/guoyuqi0554/article/details/17678459">https://blog.csdn.net/guoyuqi0554/article/details/17678459</a></li>
</ul>
<h4 id="Written-By-多点-移动运营研发部-任冰"><a href="#Written-By-多点-移动运营研发部-任冰" class="headerlink" title="Written By 多点-移动运营研发部-任冰"></a>Written By 多点-移动运营研发部-任冰</h4>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>网络知识</tag>
      </tags>
  </entry>
</search>
